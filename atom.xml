<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AirCloud 日常</title>
  <icon>https://www.gravatar.com/avatar/2f58f77d5b516b291563686ed164bd51</icon>
  <subtitle>sometimes code, sometimes design</subtitle>
  <link href="http://niexiaotao.cn/atom.xml" rel="self"/>
  
  <link href="http://niexiaotao.cn/"/>
  <updated>2022-04-13T07:07:01.192Z</updated>
  <id>http://niexiaotao.cn/</id>
  
  <author>
    <name>Xiaotao Nie</name>
    <email>onlythen@yeah.net</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《代码整洁之道-Clean Code》读书笔记</title>
    <link href="http://niexiaotao.cn/2022/02/27/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/"/>
    <id>http://niexiaotao.cn/2022/02/27/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93/</id>
    <published>2022-02-27T05:21:39.000Z</published>
    <updated>2022-04-13T07:07:01.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整洁代码"><a href="#整洁代码" class="headerlink" title="整洁代码"></a>整洁代码</h2><p>《修改代码的艺术》一书作者对整洁代码的描述：我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的，整洁的代码总是看起来像某种特别在意他的人写的，几乎没有改进的余地，代码的作者什么都想到了，如果你企图改进它，总会回到原点，赞叹某人留给的代码——全心投入某人留给你的代码。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>这本书关于函数的介绍和其他架构书差不多，主要就是两个点：1. 短小，2. 抽象层次一致性。</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>毫无疑问，注释是代码中的坏味道。</p><p>对于一部分注释，我们可以使用类似 4.4.8 这种变量的方式，通过新增两个变量，来解释我们的内容。<br>那种生成的注释和我们注释掉的代码，我的建议是：不要留。</p><h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>相关函数：按照本书的说明，若某个函数调用了另外一个，就应该把它们放到一起，而且调用者应该尽可能放在被调用者上面。我自己之前的习惯是调用者在被调用者的下面，目前又思考了一下，像作者这样组织，可能可读性反而更高。</p><blockquote><p>因为这样设计可以像报纸一样，最重要的概念先出现，并且希望以包括最小的细节表述他们，期望底层的细节后出现。</p></blockquote><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p><strong>使用异常而非返回码</strong>： 在 《代码精进之路》的读书笔记中，也提及了类似的思路，这个书里面又提到了使用异常而非返回码这一点，并且给出了一个新的理由，返回码意味着我们需要立即处理，这个步骤可能很容易被遗忘，而且会让我们的代码变得比较乱。</p><p>关于返回 null 值：有的时候，我们在数据处理中出现问题，可能会返回一个 null 或者 undefined。但是我建议相对于此，我们更应该直接抛出异常，返回 null 值意味着依赖调用者来做空检查，而且你不知道这个 null 究竟什么时候才会引发错误，这样会有较高的不稳定性。</p><h2 id="类的组织"><a href="#类的组织" class="headerlink" title="类的组织"></a>类的组织</h2><p>对于类的组织中，属性顺序的一个建议：依次是公共静态常量、私有静态变量、公共函数、私有函数。</p><p><strong>类的权责</strong>：对于一个类来说，我们不希望它被定义的太长，当然这个不能单纯地使用代码行数来判断，我们应该使用类的权责来判断，当一个类的名称越含糊，该类越有可能拥有更多权责，比如它的名称包含了诸如 Processor、Manager 或 Super，那么这种现象往往说明有不恰当的权责聚集的情况出现。</p><p><strong>如何把类拆的短小</strong>：我给出一个切实可行的办法，可以先从类的复杂函数入手，我们在把函数拆分的过程中，发现某些部分拆分成函数之后会传递大量的参数给它，否则很难拆分，那么传递给它这个函数的参数就可以被整合进新的小类的实体变量，这样我们就无需传递参数，同时也完成了拆分。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;整洁代码&quot;&gt;&lt;a href=&quot;#整洁代码&quot; class=&quot;headerlink&quot; title=&quot;整洁代码&quot;&gt;&lt;/a&gt;整洁代码&lt;/h2&gt;&lt;p&gt;《修改代码的艺术》一书作者对整洁代码的描述：我可以列出我留意到的整洁代码的所有特点，但其中有一条是根本性的，整洁的代码总是看</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://niexiaotao.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>使用 fst-json 自动生成更快的 json 序列化方法</title>
    <link href="http://niexiaotao.cn/2022/02/11/fst-json/"/>
    <id>http://niexiaotao.cn/2022/02/11/fst-json/</id>
    <published>2022-02-11T10:45:54.000Z</published>
    <updated>2022-04-13T07:07:01.188Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>fst-json 的全称是 “fast-safe-typescript json”，它的本质就是直接使用你定义好的 Typescript 文件，来生成更加高效的序列化方法。<br>其目的是利用现有的资源（开发过程编写的 Typescript 文件），在编译和开发阶段尽可能提高运行时性能，同时这个过程并没有额外的开发负担。</p></blockquote><p>github: <a href="https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md">https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md</a></p><p>知乎：<a href="https://zhuanlan.zhihu.com/p/466572196">https://zhuanlan.zhihu.com/p/466572196</a></p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>由于 JSON schema 这个概念是由 fastify 引入，我们先对此进行介绍。</p><p><a href="https://github.com/fastify/fastify">fastify</a> 是一个高性能 Node.JS 服务端框架，其特点就是高性能，而之所以高性能主要的原因就是它引入了 JSON schema，通过对参数增加约束，来获得更快的序列化速度。</p><p>同时，fastify 也开源了一个独立的 json 序列化库 <a href="https://github.com/fastify/fast-json-stringify">fast-json-stringify</a>，可以在<strong>非 fastify 的项目中使用</strong>。</p><p>在 fastify 中，JSON schema 的大致写法如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const schema = &#123;</span><br><span class="line">  <span class="keyword">schema</span>: &#123;</span><br><span class="line">    response: &#123;</span><br><span class="line">      <span class="number">200</span>: &#123;</span><br><span class="line">        <span class="keyword">type</span>: <span class="string">&#x27;object&#x27;</span>,</span><br><span class="line">        properties: &#123;</span><br><span class="line">          hello: &#123;</span><br><span class="line">            <span class="keyword">type</span>: <span class="string">&#x27;string&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fastify</span><br><span class="line">  .<span class="keyword">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">schema</span>, <span class="keyword">function</span> (req, reply) &#123;</span><br><span class="line">    reply</span><br><span class="line">      .send(&#123; hello: <span class="string">&#x27;world&#x27;</span> &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>我们可以看出，这一套写法不仅会带来额外的学习成本，而且由于目前大多数项目开发都是采用 Typescript，这套定义也会和我们的 Typescript 定义有所重复。</p><p>事实上，虽然上面的示例代码比较短小，但是在实际的项目中，接口比较多的情况下，这些代码的开发量和额外的学习/维护成本还是不容小视的。</p><p>那么有没有可能直接使用 Typescript，而不用重新定义 JSON schema 呢？</p><p>答案是有的。</p><p><a href="https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md">fst-json</a> 就是这样一个工具，它可以通过复用我们在 Typescript 中定义的 schema，通过工具自动生成 fastify 需要的 schema，这样我们就无需额外维护 schema 定义了。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>接下来，我们简单介绍 fst-json 的使用方式，首先安装（全局或者安装到项目中）：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> i fst-json -g</span><br></pre></td></tr></table></figure><p>假设我们项目采用了 Typescript，事先已经有了 schema 文件：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export <span class="keyword">interface</span> <span class="symbol">HellWorld</span> &#123;</span><br><span class="line">  attr1: <span class="built_in">string</span>;</span><br><span class="line">  attr2: <span class="built_in">string</span>;</span><br><span class="line">  attr3?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在项目目录下新建 .fstconfig.js，用于声明配置，配置如下：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.<span class="built_in">exports</span> = &#123;</span><br><span class="line">  sourceFiles: [</span><br><span class="line">    <span class="string">&#x27;./src/schema/*.ts&#x27;</span></span><br><span class="line">  ],</span><br><span class="line">  distFile: <span class="string">&quot;./src/schema-dist.ts&quot;</span>,</span><br><span class="line">  format: <span class="string">&#x27;fastify&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们运行：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fst-json gen</span></span><br></pre></td></tr></table></figure><p>然后此时会生成一个 <code>src/schema-dist.ts</code>，这里会有自动生成的 JSON schema 定义，接下来我们在项目中可以同时使用 JSON schema 定义和我们之前定义好的 Typescript 类型：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="keyword">schemas</span> <span class="keyword">from</span> <span class="string">&#x27;./schema-dist&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; HellWorld  &#125; <span class="keyword">from</span> &quot;./schema&quot;;</span><br><span class="line"></span><br><span class="line">const schema = &#123;</span><br><span class="line">  <span class="keyword">schema</span>: &#123;</span><br><span class="line">    response: &#123;</span><br><span class="line">      <span class="number">200</span>: <span class="keyword">schemas</span>.HellWorldSchema</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">server</span></span><br><span class="line">  .<span class="keyword">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">schema</span>, <span class="keyword">function</span> (req, reply) &#123;</span><br><span class="line">    let res: HellWorld = &#123;</span><br><span class="line">      attr1: <span class="string">&#x27;hello&#x27;</span>, </span><br><span class="line">      attr2: <span class="string">&#x27;world&#x27;</span>, </span><br><span class="line">      attr3: <span class="string">&#x27;optional&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply</span><br><span class="line">      .send(res);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>当然，fst-json 不仅仅可以在 fastify 中使用，也可以在任何其他需要 JSON 加速的地方使用，用法也都很简单，可以参考这个 <a href="https://github.com/aircloud/fst-json/tree/master/examples/helloworld">HelloWorld</a></p><h2 id="原理和优势"><a href="#原理和优势" class="headerlink" title="原理和优势"></a>原理和优势</h2><p>fst-json，实际上是通过对 Typescript 进行语法树解析，针对 export 导出的各种类型生成对应的 fast-json-stringify 的 JSON schema，所以运行速度和手写是没有区别的。因此，它不仅仅能完全使用 fast-json-stringify 的效率优势，除了减少重复开发量以外还有如下优点：</p><ul><li><strong>根据 schema 进行字段校验：</strong> 首先会进行 Tyepscript 语法校验，另外当缺失必须的属性（例如，当定义 interface 时没有被 <code>?</code> 修饰符修饰的属性缺失）的时候也会直接报错。</li><li><strong>过滤不需要的 schema 字段：</strong> 例如当把 Node.JS 当作 BFF 层的时候，可以严格按照 Typescript 的定义来返回字段，避免返回不需要的字段，从而避免上游服务的敏感字段被直接透传出去，也意味着从接口层面开始，真正做到 Fully Typed。</li><li><strong>更快的序列化速度：</strong> 根据 <a href="https://github.com/fastify/fast-json-stringify/issues">fast-json-stringify</a> 的测试，能达到接近 2 倍的 JSON 序列化速度。</li></ul><p>目前，fst-json 对常用的各类 interface、class、type 等类型定义都进行了支持，并且增加了各类 examples 和 90% 的覆盖率测试。</p><p>当然，由于 Typescript 的写法比较灵活。出于 JSON schema 本身的局限性，我们无法覆盖所有场景，所以也可以参考这里的<a href="https://github.com/aircloud/fst-json/blob/master/README.zh-cn.md#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">注意事项</a>，有针对性的对比较容易出问题的写法进行规避。</p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>fst-json 只是语法解析和生成工具，具体的运行时，实际上就是在使用 fast-json-stringify，也因此项目中需要安装 fast-json-stringify 依赖。</p><p>另外，针对 fast-json-stringify 的测试，在比较小的 payload 的情况下，它的速度是有优势的，当 payload 过大的时候，它的优势不再明显，甚至还不如 JSON.stringify。官方的描述是：</p><blockquote><p>fast-json-stringify is significantly faster than JSON.stringify() for small payloads.<br>Its performance advantage shrinks as your payload grows.</p></blockquote><p>不过事实上，这个时候你仍然可以使用 fst-json 做一些事情，例如笔者使用 fst-json 来做 bff 层对下游服务接口的持续集成兼容测试，在 Typescript 已经提前定义好了的情况下，每次测试的时候只需要请求依赖服务并且把响应字段序列化，如果没有报错并且字段序列化之后也没有变成 null（在比较复杂的接口定义中，如果个别属性定义类型和返回类型不一致，fast-json-stringify 是会直接转换成 null），就说明接口是没有变化的。可以有效避免依赖服务接口变化，却又没有及时同步到位造成暗坑的情况。</p><p>另外，其实目前 fast-json-stringify 生成序列化代码还是在运行时做的，这里的问题可能在于代码不透明，以及运行时开销和风险，笔者是希望将它的生成代码变成编译时去做，不过这样的话实际上有一点重复造轮子的错觉，所以目前还没有做这个事情。</p><hr><p>最后 <a href="https://github.com/aircloud/fst-json/">fst-json</a> 作为一个开源不久的小项目，肯定还有些需要优化和完善的地方，欢迎 star 支持和提出建议。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;fst-json 的全称是 “fast-safe-typescript json”，它的本质就是直接使用你定义好的 Typescript 文件，来生成更加高效的序列化方法。&lt;br&gt;其目的是利用现有的资源（开发过程编写的 Typescript 文件）</summary>
      
    
    
    
    
    <category term="前端综合" scheme="http://niexiaotao.cn/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>《代码精进之路》与《代码整洁之道》-读书笔记</title>
    <link href="http://niexiaotao.cn/2022/01/30/%E3%80%8A%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E4%B8%8E%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://niexiaotao.cn/2022/01/30/%E3%80%8A%E4%BB%A3%E7%A0%81%E7%B2%BE%E8%BF%9B%E4%B9%8B%E8%B7%AF%E3%80%8B%E4%B8%8E%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-30T08:14:15.000Z</published>
    <updated>2022-04-13T07:07:01.190Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过对部分重点内容罗列的方式对此两本书的读书笔记进行记录。</p><blockquote><p>《代码整洁之道-程序员的职业素养》</p></blockquote><h2 id="软件开发原则"><a href="#软件开发原则" class="headerlink" title="软件开发原则"></a>软件开发原则</h2><p>所有软件项目的根本指导原则是，软件要<strong>易于修改</strong>。如果违背这条原则搭建僵化的结构，就破坏了构建整个行业的经济模型。</p><h2 id="必备技能"><a href="#必备技能" class="headerlink" title="必备技能"></a>必备技能</h2><p>软件开发人员必须精通的事项：</p><ul><li>设计模式：必须能描述 GOF 书中的全部 24 种模式和，同时还要有 POSA 书中的多数模型的实践经验。</li><li>设计原则：必须了解 SOLID 原则，而且要深刻理解组件设计原则。</li><li>方法：必须理解 XP、Scrum、精益、看板、瀑布、结构化和分析以及结构化编程。</li><li>实践：必须掌握测试驱动开发，面向对象设计，结构化编程，持续集成和结对编程。</li><li>工作：必须了解如何使用 UML 图，DFD 图，结构图，Petri 网络图，状态迁移图表，流程图和决策表。</li></ul><h2 id="不要说“我试试”"><a href="#不要说“我试试”" class="headerlink" title="不要说“我试试”"></a>不要说“我试试”</h2><ul><li>这种类型的描述并不是承诺，实际上并没有实际意义。</li><li>而且这通常意味着你之前评估周期的时候<strong>并没有竭尽全力</strong>，否则为什么在压缩周期的讨论中还要再说“我试试”呢。</li></ul><h2 id="重新定义“完成”"><a href="#重新定义“完成”" class="headerlink" title="重新定义“完成”"></a>重新定义“完成”</h2><ul><li>有的时候，我们自欺欺人的认为任务已经完成的足够好了，然后转入下一项任务。我们会给自己找借口说，其他还没来得及完成的工作可以等到时间更充裕的时候来处理。甚至有的时候，我们会把代码提交定义为”任务完成“。这样显然是错误的。</li><li>真正的任务完成，是已经通过了测试，并且上线完成等。</li></ul><h2 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h2><ul><li>编程并非易事。越年轻的程序员可能越没有感觉，毕竟代码只不过是一堆 if 和 while 语句而已。但是随着经验增长，你会开始意识到把这些 if 和 while 语句组装在一起并非易事。不能期望将他们简单的组装到一起就能得到最好的代码。相反，必须小心谨慎地将系统分解为易于理解的单元，同时使得这些单元之间的联系越少越好。</li><li>因此，仅凭一己之力很难写出足够优秀的代码，即使你的技艺足够高超。<strong>也一定能从另外一名程序员的思考和想法中获益。</strong></li></ul><h2 id="重新认识争论"><a href="#重新认识争论" class="headerlink" title="重新认识争论"></a>重新认识争论</h2><ul><li>凡是不能在 5 分钟内解决的争论，都不能通过辩论来解决。争论之所以要花费这么长时间，是因为争论双方都拿不出足够有力的证据，这个时候争论依据的不是事实，而是信念。</li></ul><h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><ul><li>成员需要克服个体差异性，默契配合，彼此信任，形成真正有凝聚力的团队，是需要一些时间的。可能需要 6 个月，甚至一年，但是，凝聚力一旦形成，就会产生一种神奇的魔力。团队成员会一起做计划，一起解决问题，一起面对问题，<strong>一起解决一切</strong>。</li></ul><blockquote><p>《代码精进之路》</p></blockquote><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>一般来说我们都知道命名应该有可读性，但是像这里介绍这么详细的并不多。</p><p>例如我们针对命名可以通过固定分段限定词的方式进行统一：</p><ul><li><code>[动作][对象][范畴]</code>，来统一我们的命名，例如 <code>getRevenueTotal(获取总收入)</code>。</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>注释如果是对执行过程的简单复述，那么这样的注释不应该存在。</li><li>我们可以通过函数和中间变量的封装，来减少可以避免的注释。</li></ul><h2 id="错误和错误码"><a href="#错误和错误码" class="headerlink" title="错误和错误码"></a>错误和错误码</h2><p>我们可以通过以下几种方式处理错误（中后台系统比较合适）：</p><ol><li>程序运行期间的错误，一般我们可以通过 Error 打印到日志中，而且这类错误，最好和报警系统进行对接，直接输出到报警系统中。</li><li>API/服务调用错误，这种错误一般通过错误码返回给调用端的同时，也需要在日志做好记录。</li></ol><blockquote><p>关于错误码：错误码我们可以使用数字或者显示化错误码，数字的坏处即我们需要额外维护错误码表，调用者可能并非我们团队，有可能造成沟通障碍。<br>因此，更建议使用<strong>显示化错误码</strong>，并且可以做一个约定：P 代表参数异常，B 代表业务异常，S 代表系统异常，例如：P_Customer_NameIsNull 客户姓名不能为空</p></blockquote><h2 id="代码中的破窗效应"><a href="#代码中的破窗效应" class="headerlink" title="代码中的破窗效应"></a>代码中的破窗效应</h2><p>破窗效应在代码中很常见，通常在我们完成一个功能的时候，都是基于现有代码的改动，如果你可以基于一个现有代码的不良设计完成功能（例如，在已经很混乱的事件订阅类增加一个 Enum、在已经很冗长的 Http 请求列表复制一个新的出来），那么大概率你会这样做而不是重构，<strong>特别是当这个不良设计不是你最初写的时候，就更加可以心安理得的改代码而没有任何负罪感，甚至在 Code Review 的时候都可以有充足的理由：它已经是这样了，这次先上，将来找个时间整体重构才行。</strong></p><h2 id="SLAP"><a href="#SLAP" class="headerlink" title="SLAP"></a>SLAP</h2><p>SLAP：Single Level of Abstraction Principle，抽象层次一致性</p><p>SLAP 要求函数体中的内容必须在同一个抽象层次上，如果高层次抽象和低层次细节杂糅在一起，就会显得凌乱，难以理解。</p><h2 id="如何述职"><a href="#如何述职" class="headerlink" title="如何述职"></a>如何述职</h2><ul><li>方法1: <strong>提出问题，定义问题，分析问题，解决问题，最后展望未来</strong>。这个也是麦肯锡常用的方法。</li><li>方法2: 我们说事情的时候，应该像电影镜头一样，先由远拉近，再由近拉远。从宏观背景，到怎么做的，到结果和思考。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文通过对部分重点内容罗列的方式对此两本书的读书笔记进行记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《代码整洁之道-程序员的职业素养》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;软件开发原则&quot;&gt;&lt;a href=&quot;#软件开发原则&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://niexiaotao.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《重构》-读书笔记</title>
    <link href="http://niexiaotao.cn/2022/01/02/%E9%87%8D%E6%9E%84-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://niexiaotao.cn/2022/01/02/%E9%87%8D%E6%9E%84-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-02T06:11:39.000Z</published>
    <updated>2022-04-13T07:07:01.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始重构"><a href="#开始重构" class="headerlink" title="开始重构"></a>开始重构</h2><p>如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添加该特性。<br>重构前，先检查自己是否有一套可靠的测试集，这些测试必须有自我检视的能力。</p><blockquote><p>事实上很多时候，测试集都是被我们忽略的</p></blockquote><p>营地法则：保证你离开的时候代码库一定比原来的更加健壮。</p><p>什么是重构？根据重构这本书的定义，如果有人说他们的代码在重构过程中有一两天的时间是不可用的，基本上可以确定，他们在做的事情不是重构。</p><h2 id="何时重构"><a href="#何时重构" class="headerlink" title="何时重构"></a>何时重构</h2><p>事不过三法则（Rule of Three）：第一次做某件事情的时候只管去做，第二次做某件事情的时候会产生反感，但无论如何还是可以去做，第三次再做类似的事情，你就应该重构。</p><blockquote><p>在《代码精进之路》这本书中，也提到了这个原则。</p></blockquote><p>另外的一个时机是，每次要修改时，首先令修改很容易（警告：这件事有时候会很难），然后再进行这次的修改。</p><blockquote><p>比如，笔者最近在做一个长链接客户端 SDK，最初这个 SDK 功能很简单，我直接加功能即可，后面有一次当我要修改的时候，我发现这个 SDK 的修改已经变得异常复杂了，这个时候我知道我应该重构了。</p></blockquote><h2 id="重构法则"><a href="#重构法则" class="headerlink" title="重构法则"></a>重构法则</h2><p>这里对一些我们实际场景中遇到，但是通常会被我们忽视的一些法则进行列举。</p><h3 id="霰弹式修改"><a href="#霰弹式修改" class="headerlink" title="霰弹式修改"></a>霰弹式修改</h3><p>如果我们代码中的模块特别多，如果我们每次遇到一个变化都需要在不同的小模块中做许多小修改，我们所面临的坏味道就是霰弹式修改。<br>这个时候我们需要思考重构，最好我们不同的模块都是正交的。</p><h3 id="慎重注释"><a href="#慎重注释" class="headerlink" title="慎重注释"></a>慎重注释</h3><p>有的时候，我们写注释是因为这段对应的代码逻辑很糟糕。<br>因此当你感觉需要撰写注释的时候，请先尝试重构，试着将所有的注释变成多余。</p><h3 id="提炼变量"><a href="#提炼变量" class="headerlink" title="提炼变量"></a>提炼变量</h3><p>对于复杂语句，提炼变量可以增加可读性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;开始重构&quot;&gt;&lt;a href=&quot;#开始重构&quot; class=&quot;headerlink&quot; title=&quot;开始重构&quot;&gt;&lt;/a&gt;开始重构&lt;/h2&gt;&lt;p&gt;如果你要给程序添加一个特性，但发现代码因缺乏良好的结构而不易于进行更改，那就先重构那个程序，使其比较容易添加该特性，然后再添</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://niexiaotao.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《架构整洁之道》-读书笔记</title>
    <link href="http://niexiaotao.cn/2021/12/26/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://niexiaotao.cn/2021/12/26/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2021-12-26T06:38:52.000Z</published>
    <updated>2022-04-13T07:07:01.194Z</updated>
    
    <content type="html"><![CDATA[<p>这本书之前刚工作的时候略有耳闻，不过当时简单翻阅了下，并没有什么共鸣，可能是编程经验太少导致，但最近我再重读这本书的时候，感觉之前自己或所在团队确实踩了不少类似的坑，也渐渐了解到，很多复杂的项目和工程背后，其实往往是一些最朴素的道理，软件工程的发展也并没有上层框架的发展那么快。</p><p>也因此，本篇博客作为一个读书笔记性质，可能有些地方也并非足够连贯。</p><h2 id="如何看待软件架构设计"><a href="#如何看待软件架构设计" class="headerlink" title="如何看待软件架构设计"></a>如何看待软件架构设计</h2><p>软件架构设计的终极目标：用最小的人力成本来满足构建和维护该系统的需求。</p><p>很多时候，对于一个系统，一开始我们的开发效率接近 100%，然而伴随产品的每次发布，生产力直线下降。工程师的大部分时间都是消耗在对现有系统的修修补补上面，而不是真正完成实际的功能。拆东墙补西墙，周而往复。公司需要的人力成本也因此变多了，但是效益却没有提升。</p><p>初级工程师总是会犯的一个问题是：持续低估良好的设计，整洁的代码的重要性，并且普遍采用一种话术来欺骗自己：我们可以未来在重构代码，产品上线最重要。而实际上，产品上线之后疲于应付新需求已经很累了，就很难有重构的时机。</p><p>实际上，一般软件开发都会被设计成如下三个阶段，这可能并没有错：</p><ol><li>先让代码工作起来</li><li>试图让它变好：通过优化和重构，让人更好地理解代码，并且适应新需求。</li><li>试着让它运行的更快</li></ol><p>所以，我们确实需要理解整洁架构的重要性，避免我们在 1 和 2 循环往复。</p><p>软件设计的第一条原则：不管是为了可测试性还是其他什么东西——<strong>是不变的，就不要依赖于多变的东西。</strong></p><h2 id="软件系统"><a href="#软件系统" class="headerlink" title="软件系统"></a>软件系统</h2><p>软件系统的价值维度：行为和架构。</p><p><strong>变更的实施难度应该和变更的范畴成等比关系，而与变更的具体行为无关</strong>。</p><blockquote><p>有的时候，产品经理会表示，我就改一个小点，为什么需要几天时间？开发人员会找一大堆理由，通常不会提及架构的不合理性。实际上这种现象在我毕业入职的第一家公司时有发生。</p></blockquote><h2 id="编程范式"><a href="#编程范式" class="headerlink" title="编程范式"></a>编程范式</h2><p>目前，我们主要有三个编程范式：结构化编程，面向对象编程，函数式编程。这些编程范式都是在 20 世纪被提出来的，而且在有限的时间中估计也不会新增编程范式了。</p><ul><li>结构化编程：if/then/else 和 do/while/util</li><li>面向对象编程</li><li>函数式编程：值不可变，对赋值进行了限制和规范</li></ul><p>三个编程范式，分别限制了 goto 语句、函数指针和赋值语句的使用。</p><h3 id="结构化编程"><a href="#结构化编程" class="headerlink" title="结构化编程"></a>结构化编程</h3><p>程序员可以用代码将一些已经证明可用的结构串联起来，只要自行证明这些额外代码是正确的，就可以推导出整个程序的正确性。</p><p>goto 语句，让我们的程序很难被分成这种小块。</p><p>关于验证：科学理论和科学定律的特点：他们可以被证伪，但是没有办法被证明，实际上现有的编程大部分也采用了这种理念，我们没用使用完整的形式化证明，而是使用测试用例，测试没有问题后，即发布到线上。</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><ul><li>封装、继承、多态都不是面向对象创造出来的，但是确实使用起来更方便了。</li><li>依赖反转也通常是面向对象的特点。</li><li>独立部署：当某个组件的源代码需要修改，仅仅需要重新部署该组件即可，不需要修改其他组件。</li></ul><p><strong>面向对象编程就是以多态为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师能够构建出某种插件结构，让高层策略性的组件和底层实现的组件相分离，底层组件可以被编译成插件，实现独立于高层组件的开发和部署。</strong></p><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul><li>所有的竞争问题、死锁问题、并发更新问题都是由可变变量导致的，如果变量永远不能被篡改，那就不可能产生竞争或并发更新的问题。如果锁的状态是不可变的，那就永远不会产生死锁问题。</li><li>一个个架构设计良好的应用程序应该将状态修改的部分和不需要修改状态的部分隔离承担度的组件，然后通过合适的机制保护可变量。</li><li>软件架构师应该着力于将大部分处理逻辑都归于不可变组件中，可变状态组件的逻辑越少越好。</li></ul><p>一种函数式编程理念的开发方式：<br>事件溯源：我们只存储事务记录，不存储具体状态，当需要计算具体状态的时候，我们只需要重头开始计算所有的事务即可。同时，我们也把 CURD 变成了 CR。</p><h2 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h2><p>我们为软件构建中层结构的主要目标：</p><ol><li>使软件可容忍被改动。</li><li>使软件更容易被理解。</li><li>构建可在多个软件系统中复用的组件。</li></ol><p>SOLID 原则 分为以下几点：</p><ul><li>SRP：单一职责原则，任何一个软件模块都应该有且只有一个被修改的原因。避免多人为了不同的目的修改同一份原代码文件。</li><li>OCP：开放封闭原则，通过新增代码来修改原有的行为，而非只靠修改源代码。</li><li>LSP：里氏替换原则，组件方便被替换，每一处使用父类对象的地方，可以使用其子类对象进行替换，而保持其行为不变。</li><li>ISP：接口隔离原则，避免不必要的依赖。</li><li>DIP：依赖反转原则，高层代码不应该依赖底层细节。如果我们想要设计一个灵活的系统，在源代码层次的依赖关系中就应该多引用抽象类型，而非具体实现。<ul><li>优秀的软件架构师会花费很大力气来设计接口，以减少未来对其进行的改动。毕竟在不修改借口的情况下为软件增加新的功能是软件设计的基础常识。</li></ul></li></ul><blockquote><p>实际上我们在实现 TS 库代码的时候经常用到 DIP，比如我们底层代码需要用到上层的一个功能，我们通常定义一个抽象类或者抽象函数，然后由上层来实现，这种场景即是 DIP。<br>例如，在我们写一个库的时候，通常会定义一个抽象，然后由外层传入实现这个 log，而不是在库代码中直接依赖某种 log 实现（可以有一个默认的实现），这个即是 DIP 的一个运用。</p></blockquote><h2 id="组件构建原则"><a href="#组件构建原则" class="headerlink" title="组件构建原则"></a>组件构建原则</h2><p>组件是软件的部署单元。</p><ul><li>REP：复用/发布原则：软件复用的最小粒度应等同于其发布的最小粒度。</li><li>CCP：共同闭包原则：我们应该将那些会同时修改，并且为相同目的而修改的类放到同一个组件中，而将不会同时修改，并且不会为了相同目的而修改的那些类放到不同的组件中。<ul><li><strong>对于大部分项目来说，可维护性的重要性远远大于复用性</strong>（精髓所在，以前一直觉得复用重要，但回头想想，对于一个项目而言，维护成本才是最直观的指标，这里设计修改所需要的人力成本，最终还是利益如何最大化的问题）</li></ul></li><li>CRP：共同复用原则：实际上是 LSP 原则的一个普适版，LSP 原则是建议我们不要依赖带有不需要函数的类，CRP 原则则是建议我们不要依赖带有不需要的类的组件。</li></ul><p>REP 和 CCP 是粘合性原则，他们会让组件变得更大，而 CRP 是排除性原则，它会尽量让组件更小。</p><p>组件耦合原则：</p><ul><li>无依赖环原则：整体依赖应该是一个有向无环图。</li><li>稳定依赖原则：<strong>依赖关系必须要指向更稳定的方向。</strong>我们可以通过组件的依赖和被依赖的关系计算它的位置稳定性。</li><li>稳定抽象原则：一个组件的抽象化程度应该与其稳定性保持一致。稳定的组件应该是抽象的，那么它的稳定性就不会影响到扩展性。</li></ul><h2 id="软件架构流程"><a href="#软件架构流程" class="headerlink" title="软件架构流程"></a>软件架构流程</h2><p>整体包括：运行、维护、开发、部署</p><p>什么是软件架构师？软件架构师实际上应该是能力最强的一群程序员，他们通常会在自身承接编程任务的同时，逐渐引导整个团队向一个能够最大化生产力的系统设计方向演进。所以我们有时候误以为架构师就不写代码了，这当然是错的。</p><p>软件架构设计的三个工作：组件的切分，组件的组合，以及组件的相互通信。</p><p>软件架构设计的终极目标：最大化程序员的生产力，最小化系统的总运营成本。</p><p>关于部署：一般一个系统的部署成本越高，它的可用性就越低</p><blockquote><p>例如在系统早期开发中，我们可能会决定采用某种微服务架构，但当我们实际部署这个系统的时候，我们就会发现微服务的数量已经庞大到令人生畏，这也就是笔者之前所在公司遇到的问题：一开始通过 golang 微服务实现整个系统，后面决定私有化部署后，迁移成本巨大，不得不进行了微服务的合并。</p></blockquote><p>运行：<strong>对于一个因架构设计糟糕而效率低下的系统，我们通常只需要增加更多的存储器与服务器，就能够让它圆满的完成任务。另外，硬件也远远比人力便宜，这也是软件架构对系统运行的影响远远没有它对开发、部署、维护的影响那么深刻的原因</strong><br>笔者现在确实应该意识到这个问题。</p><p>基于以上设计的架构：UI 界面 - 系统独有的业务能力 - 领域普适的业务能力 - 数据库</p><p>重复：<em>架构师经常会钻进一个牛角尖：害怕重复</em>。虽然软件代码编写的原则是 <code>don&#39;t repeat yourself</code>，但是有的时候，对于两个后期发展偏差很大的组件，如果只是存在一些暂时的重复，是我们完全可以容忍的。我们应该根据实际情况来决定是否要重复。</p><h2 id="划分边界"><a href="#划分边界" class="headerlink" title="划分边界"></a>划分边界</h2><p>软件开发技术发展史，就是一个如何想法设法方便增加插件，从而构建一个可扩展，可维护的系统架构的故事，系统的核心业务逻辑必须和其他组件隔离，保持独立，而这些其他组件要么是可以去掉的，要么是有多重实现的。<br>同时，插件部分的变更实际上不应该影响系统核心逻辑的变更。</p><blockquote><p>这里举例：比如说当我们设计一个多节点 server，它依赖一个分布式存储系统，我们不应该在 server 中把这个分布式存储系统默认为 redis, 而应该定义接口能力即可。</p></blockquote><p>如何分层：本质上，所有的软件系统都是一组策略语句的集合。我们需要将这些策略彼此分离，并且将它们按照变更的方式进行重新分组。其中变更的原因，时间和层次相同的策略应该分到一个组件中。反之，变更原因、时间和层次不同的策略应该分属不同的组件。最终它们是一个有向无环图。</p><h2 id="整洁架构"><a href="#整洁架构" class="headerlink" title="整洁架构"></a>整洁架构</h2><ul><li>六边形架构</li><li>DCI 架构</li><li>BCE 架构</li></ul><p>这些架构通常有以下特点：</p><ol><li>独立于框架</li><li>可被测试：这些系统的业务逻辑可以脱离 UI、数据库、Web服务以及其他外部元素来进行测试。</li><li>独立于 UI，并且比较方便地在不改动业务逻辑的情况下改动 UI</li><li>独立于数据库，以及独立于其他外部机构</li></ol><p>谦卑对象模式：</p><p>谦卑对象的解读：我们可以将软件模块分为两组，一组是谦卑组，另外一组不是。谦卑组的模块通常比较难写代码进行测试，比如 GUI，这部分代码应该越简单越好。</p><p>门户模式：Facade Pattern<br>外部只能看到 Facade，然后 Facade 内部的 implement 可以有一个或者多个。</p><blockquote><p>这种模式在我们重构项目的时候挺有用的，我们可以实现一个 Facade 类，然后默默把里面的实现灰度或者直接换掉。</p></blockquote><h2 id="服务和架构"><a href="#服务和架构" class="headerlink" title="服务和架构"></a>服务和架构</h2><p>实际上，服务本身只是一种比函数调用成本稍微高的，分割应用程序的一种形式，与数据库无关。</p><p><strong>服务真的解耦了么？因为通常服务不能彼此访问变量，我们会认为这种设计自然就解耦了。但实际上，任何形式的共享数据都会导致强耦合，比如它们依赖同一种数据结构、同一个 schema。而且在这种情况下，它们的 dev ops 也并不是独立的。</strong></p><hr><p>&lt;完&gt;</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这本书之前刚工作的时候略有耳闻，不过当时简单翻阅了下，并没有什么共鸣，可能是编程经验太少导致，但最近我再重读这本书的时候，感觉之前自己或所在团队确实踩了不少类似的坑，也渐渐了解到，很多复杂的项目和工程背后，其实往往是一些最朴素的道理，软件工程的发展也并没有上层框架的发展那么</summary>
      
    
    
    
    
    <category term="读书笔记" scheme="http://niexiaotao.cn/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="架构" scheme="http://niexiaotao.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>React Conf 2021 内容概要</title>
    <link href="http://niexiaotao.cn/2021/12/08/ReactConf2021/"/>
    <id>http://niexiaotao.cn/2021/12/08/ReactConf2021/</id>
    <published>2021-12-08T14:59:00.000Z</published>
    <updated>2022-04-13T07:07:01.187Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://zhuanlan.zhihu.com/p/447103166">https://zhuanlan.zhihu.com/p/447103166</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原文：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/447103166&quot;&gt;https://zhuanlan.zhihu.com/p/447103166&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="React" scheme="http://niexiaotao.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>PC 开发技术选型：Electron 不是银弹</title>
    <link href="http://niexiaotao.cn/2021/09/16/electron%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%98%AF%E4%BD%A0%E7%9A%84%E8%A7%A3%E8%8D%AF/"/>
    <id>http://niexiaotao.cn/2021/09/16/electron%E5%8F%AF%E8%83%BD%E4%B8%8D%E6%98%AF%E4%BD%A0%E7%9A%84%E8%A7%A3%E8%8D%AF/</id>
    <published>2021-09-16T07:01:35.000Z</published>
    <updated>2022-04-13T07:07:01.188Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.electronjs.org/docs">Electron</a> (类似的还有 nw.js）是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入了 Chromium 和 Node.js。</p><p>也就是说，我们几乎可以使用纯 web 技术，来创建跨平台的 windows 和 macOS 的原生应用，并通过 Node.js addon 能力接入 native 模块。目前市面上，也有一大批知名的应用是使用 Electron 开发的，比如：VS Code、Atom、Microsoft Teams 等（<em>在 macOS 上面一个简单的判断应用是否使用了 Electron 的办法：在应用的 Contents/Frameworks 里面搜索是否有 Electron Framework.framework</em>）。</p><p>但实际上，这篇文章是希望你在选用 Electron 框架前，需要进行慎重的考虑和评估。国内有很多公司，包括一些一线互联网公司的项目是一开始为了快速迭代选择了 Electron，后续实在无法进一步优化，全部推到重来，这实际上反而不利于整体的项目迭代。</p><h1 id="架构选型"><a href="#架构选型" class="headerlink" title="架构选型"></a>架构选型</h1><p>一般来说，笔者认为有以下几个场景，不适合使用 Electron 进行开发：</p><h2 id="1-无页面或者少量页面的应用"><a href="#1-无页面或者少量页面的应用" class="headerlink" title="1. 无页面或者少量页面的应用"></a>1. 无页面或者少量页面的应用</h2><p>这一点很好理解，Electron 的便利性主要体现在页面相关的开发，如果你的应用几乎没有页面，比如只在顶部状态栏区域有一个按钮，显然就没有必要使用 Electron，直接使用原生的技术栈即可。</p><h2 id="2-对安装包体积限制较为严格的应用"><a href="#2-对安装包体积限制较为严格的应用" class="headerlink" title="2. 对安装包体积限制较为严格的应用"></a>2. 对安装包体积限制较为严格的应用</h2><p>Electron 由于自身携带的基础设施，导致即使你的业务代码不多，初始安装包也会比较大（毕竟接近一个浏览器的大小），在没有你的业务代码的情况下，未经优化的安装包达到了 60MB 左右，而且通常你需要把 node_modules 一起打进去，所以即使你的业务并不复杂，也很容易产生一个接近 100MB 的安装包。</p><p>因此，如果你的业务需要比较极致的包体积优化，那么 Electron 可能并不是一个合适的选择。</p><h2 id="3-多窗口应用"><a href="#3-多窗口应用" class="headerlink" title="3. 多窗口应用"></a>3. 多窗口应用</h2><p>Electron 的进程模型为一个主进程 + 若干渲染进程，每一个渲染进程用于展示一个页面，<strong>即使你的页面是 Hello World，内存占用也达到 50 MB 左右</strong>。</p><p>也就是说，如果你的应用需要同时展示多个窗口，那么就需要多个渲染进程，这样整体的内存占用就会上涨很多，而实际上我们使用原生或者其他的类 cef 的方案，是可以做到一个进程对应多个窗口的。</p><h2 id="4-性能消耗较高并且需要高度定制优化的应用：比如视频类应用"><a href="#4-性能消耗较高并且需要高度定制优化的应用：比如视频类应用" class="headerlink" title="4. 性能消耗较高并且需要高度定制优化的应用：比如视频类应用"></a>4. 性能消耗较高并且需要高度定制优化的应用：比如视频类应用</h2><p>Electron 基于 web 架构，所以使用 Electron 开发的应用性能一般来说和 web 比较接近，当然，我们可以通过 Node.js addon 加持的方式让部分场景下性能更高（比如直接使用 c++ 实现一些计算密集型的模块，或者独立出一个非 UI 进程，来处理非 UI 逻辑），不过页面 UI 相关的还是会受限制于 web 的天花板。</p><p>所以，一般来说，以下两种情况可能不适用于 Electron：</p><ol><li><p>在 web 场景下，UI 元素操作比较卡顿，达到瓶颈，必须采用性能更高的原生 UI。不过我建议<strong>不要轻易下这个结论</strong>，一般情况下这种性能问题都是写的代码不够极致，建议先从 web 的角度进行性能优化（比如，长列表场景我们可以<a href="http://niexiaotao.cn/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/">通过压缩合成层优化性能</a>来数十倍地提高性能）。</p></li><li><p>对某一项技术有深度依赖，而这项技术在 web 方面存在性能上的天花板。事实上这种情况也并不多见，其中一个合理的场景是视频相关的应用，比如视频会议，或者视频播放器，这类由于 Chrome 本身的渲染流水线的限制，使用 video 标签或者使用 WebGL 都会存在一些性能问题，这个时候我们需要更深入的去进行相关能力的定制，就需要从 Electron 的框架中跳脱出来，或者针对 Electron 进行二次开发。</p></li></ol><blockquote><p>关于 WebGL: 实际上很多 web 开发者会把 WebGL 当作部分场景下性能优化的银弹，但实际上 WebGL 目前存在诸多困境：WebGL 1.0 虽然已经普及，但是其作为 OpenGL ES 2.0 的子集，性能上已经并不特别适用现代硬件架构；而 WebGL 2.0 目前仍然在普及中并且各家厂商意见无法一致；Web GPU 可能是一个更好的解决方案，底层直接对接 D3D12、metal、vulkan 等更底层更先进的图形框架，但目前成熟度不高。</p></blockquote><p>如果你的应用在经过以上分析之后，认为仍然可以使用 Electron 进行开发，那么恭喜你拥有了一个如此高效率的开发方案（如果不行，建议你可以选择其他的解决方案，比如 <a href="https://www.qt.io/">QT</a>）。</p><p>当然在此基础上，我们仍然需要进行充足的性能优化和稳健的架构设计，来让我们应用的可靠性变得更高。</p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>和 web 不同的是，我们的 native 应用需要更加关注如下三个指标：</p><h2 id="1-cpu"><a href="#1-cpu" class="headerlink" title="1. cpu"></a>1. cpu</h2><p>cpu 占用相关的问题，我们在 web 技术栈中一般也会关注，不过更多的是关注函数的调用耗时，是否存在同步调用的耗时过长导致卡顿等问题。</p><p>而在桌面应用程序的场景中，我们需要从整个应用的维度关注 cpu 消耗，并且需要更加重视。</p><p>另外一个原因是，在网页场景中，页面的 cpu 占用通常不会特别直观地被用户发现（因为系统层面通常只会体现在浏览器占用 cpu 较多），而在现在的原生场景，用户可以直接在任务管理器中看到我们的应用，如果我们的应用持续有一个较高的 cpu 占用，就会比较容易被用户发现，甚至触发系统告警提示强杀应用，这对我们应用的口碑也是一个比较负面的影响。</p><h2 id="2-内存"><a href="#2-内存" class="headerlink" title="2. 内存"></a>2. 内存</h2><p>在桌面应用程序中，内存的使用方式有了一个明显的变化：</p><p>原有的 web 页面，通常是用完即走，而对于 native 应用用户一般会打开很久，这也就意味着我们如果一旦产生内存泄漏或者内存占用比较高的情况，对用户的影响是持续并且被不断放大的。</p><p>对于 cpu 和内存的分析，我们可以通过以下方式：</p><ol><li>开发阶段通过 visual studio 或 instruments 来详细分析我们开发的功能的 cpu 和内存分配情况，发现问题。</li><li>测试发布阶段通过第三方内存分析工具，流程化的分析 cpu 和内存占用并产出报告。</li><li>线上阶段持续监控 cpu 和内存消耗情况，并且上报数据进行统计和监控告警。</li></ol><h2 id="3-crash-率"><a href="#3-crash-率" class="headerlink" title="3. crash 率"></a>3. crash 率</h2><p>实际上在前端领域基本上没有 “crash” 这个说法，不过对于 native 应用来说，即使我们的应用是完全采用前端技术栈，也可能存在 crash (crash 在 Electron 的代码），一般这个时候用户的体验是闪退，相对来说算是严重影响用户体验的问题，因此值得我们足够的重视。</p><p>对于 crash 问题我们应该做好以下三点：</p><ol><li>运行时 crash 监听机制，一般是 sentry 或者直接使用其依赖的 crash_pad。</li><li>符号管理机制，管理我们原生模块，和我们用到的 Electron 对应版本的符号。</li><li>运行时 crash 上报告警机制。</li></ol><h1 id="架构优化"><a href="#架构优化" class="headerlink" title="架构优化"></a>架构优化</h1><p>除了上述性能指标和监控手段，我们可以通过一定的架构优化，来增强系统的可靠性。</p><h2 id="通过-Node-js-addon-或者独立进程的方式原生实现非-UI-内容"><a href="#通过-Node-js-addon-或者独立进程的方式原生实现非-UI-内容" class="headerlink" title="通过 Node.js addon 或者独立进程的方式原生实现非 UI 内容"></a>通过 Node.js addon 或者独立进程的方式原生实现非 UI 内容</h2><p>这里的作用主要是希望能够借助原生模块的高性能优化 cpu 的占用。</p><p>Electron 让我们开发 ui 相关的页面变得非常高效，但是一些逻辑部分，或者和操作系统进行交互的部分，我们还是需要原生开发的手段，毕竟即使使用了 Node.js，也无法直接进行系统调用。</p><p>这里我们可以采用 Node.js addon 的方式或者独立进程+进程间通信的方式，两者的好处分别是：</p><p>addon：</p><ol><li>方便进行内存共享。</li></ol><p>独立进程：</p><ol><li>通常会增加可靠性，独立进程挂掉后可以单独重启，不影响用户界面。</li><li>需要防止大块的内存重复占用，可以通过共享内存等方式来进行优化。</li></ol><h2 id="减少或者禁止在渲染进程使用-remote"><a href="#减少或者禁止在渲染进程使用-remote" class="headerlink" title="减少或者禁止在渲染进程使用 remote"></a>减少或者禁止在渲染进程使用 remote</h2><p>有的时候，即使 electron 的技术选型适合你的项目，但如果滥用 remote 也会造成整个应用的大量不稳定与卡顿。</p><p>实际上，我们可以通过阅读 electron 的源代码发现，remote 模块只是对 IPC 消息的同步封装，方便渲染进程调用主进程的对象和方法，而不必显式发送消息进行进程间通信。所以，由于其屏蔽了内部的进程间通信，在调用的时候基本无感主进程的存在和 IPC 的风险，但事实上这却有卡顿甚至卡死渲染进程的风险。</p><p>另外，去掉 remote 还有另外一个好处，就是方便我们项目的 PC 版本和 web 版本进行同构，具有更高的可维护性。</p><p>所以针对一般的项目，笔者建议能禁用就禁用 remote，规避此隐患。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><p>我们可以在代码编写和打包的过程中，做一些其他的优化，在这里，大部分前端的优化比如动态加载、代码分割、图片缓存等大多也都适用 electron 的情况，除此之外，还有一些优化则是：</p><ol><li><p>避免重复打包：</p><ul><li><strong>避免 node_modules 和 webpack 重复的打包和引入</strong>，对于 webpack 我们可以使用 webpack-bundle-analyzer 来分析打包体积进行优化</li><li>减少无关文件的打包，可以通过配置针对 electron-builder 的 config 去除无关内容打包，同时可以使用 <a href="https://github.com/tj/node-prune">node-prune</a> 来去除无用的 node_modules 小文件。</li></ul></li><li><p><strong>v8-code-cache</strong>: </p><ul><li>可以使用 <a href="https://github.com/zertosh/v8-compile-cache">v8-compile-cache</a> 来进行一定的编译优化</li></ul></li><li><p>更多可以参考 VSCode 的相关分享：<a href="https://www.youtube.com/watch?v=r0OeHRUCCb4">https://www.youtube.com/watch?v=r0OeHRUCCb4</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.electronjs.org/docs&quot;&gt;Electron&lt;/a&gt; (类似的还有 nw.js）是一个使用 JavaScript、HTML 和 CSS 构建桌面应用程序的框架。 嵌入了 Chromium 和 Node.js。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="前端综合" scheme="http://niexiaotao.cn/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>我们应该如何进行 Code Review ?</title>
    <link href="http://niexiaotao.cn/2021/09/05/%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4MR%E7%9A%84%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/"/>
    <id>http://niexiaotao.cn/2021/09/05/%E4%B8%80%E4%BA%9B%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4MR%E7%9A%84%E9%87%8D%E7%82%B9%E5%85%B3%E6%B3%A8%E5%86%85%E5%AE%B9%E6%95%B4%E7%90%86/</id>
    <published>2021-09-05T10:51:00.000Z</published>
    <updated>2022-04-13T07:07:01.190Z</updated>
    
    <content type="html"><![CDATA[<p>笔者在日常工作中会发现，时常会存在一些比较显而易见或者已知的一类问题，在开发者提交代码以及相关同学 Review 中均未被发现。实际上，代码开发者在某些时候会提交较多代码，而此时 Reviewer 面对较多代码的 Review 的时候，很可能会漏掉一些 Review 的要点，甚至可能会感到无所适从。本文希望，针对一些非场景化的内容，整理出一些较为普适的一些原则，从而帮助 Reviewer（以及开发者本身）解决一些通用的问题。</p><h2 id="隐私性原则"><a href="#隐私性原则" class="headerlink" title="隐私性原则"></a>隐私性原则</h2><p>隐私通常涉及到法律合规，因此可能是最重要的一环。</p><h3 id="用户的隐私不可泄漏"><a href="#用户的隐私不可泄漏" class="headerlink" title="用户的隐私不可泄漏"></a>用户的隐私不可泄漏</h3><p>比如在开发功能打日志的时候，我们应该不能泄漏用户的隐私，例如用户的自定义信息、聊天信息等。</p><p>这一部分建议在团队内部形成一个统一的规范文档，在开发和 Review 的过程中，大家都可以以此为依据。</p><h3 id="自己的隐私不可泄漏"><a href="#自己的隐私不可泄漏" class="headerlink" title="自己的隐私不可泄漏"></a>自己的隐私不可泄漏</h3><p>很多时候，我们虽然注意到了用户的隐私，但是自己的隐私却没有注意，这里主要是我们的一些 appKey、密钥等内容。无论是在以下哪些场景，我们都需要格外注意：</p><ul><li>对产物进行二次分发，例如分发到内部或外部 npm、github 以及其他团队，特别是外网可访问的情况更需要注意。</li><li>直接给到用户使用，例如在 Web 环境使用，或者打包到桌面端应用，尽量避免用户直接接触到这些内容。</li></ul><h2 id="可读性-维护性"><a href="#可读性-维护性" class="headerlink" title="可读性/维护性"></a>可读性/维护性</h2><h3 id="代码提交的注释"><a href="#代码提交的注释" class="headerlink" title="代码提交的注释"></a>代码提交的注释</h3><p>对于 bug fix：很多时候我们是在处理一个边界问题，或者某种兜底，这个时候 fix 的代码可能比较难以理解，在这种情况下我们最好是写明注释，如果有相关的文档和 bug 单，我们也可以一并贴到注释中。另外，如果我们的 bug fix 是一个临时方案，请在代码中写明 TODO，来提醒自己和别人这个地方后续还会继续更改。</p><p>对于新功能添加：一般我们需要在关键入口处写明功能的说明文档链接、完善相关关键路径的注释，同时删除功能开发中的冗余代码：例如我们在开发过程中测试用到但是最终却没有用到的大段注释掉的代码，以及大段的注释和 TODO，我们都需要在最终提交的时候<strong>删除掉</strong>，如果需要找回建议使用 git 的能力，可以适当进行注释备注。</p><p>另外，对于注释来说，禁止出现模糊的词汇，例如 <code>感觉</code>，<code>好像</code>，<code>大概</code> 等这种模糊的词汇，而是要培养自己严谨的意识，已经提交的代码必须有严格的佐证。</p><h3 id="代码的通用性"><a href="#代码的通用性" class="headerlink" title="代码的通用性"></a>代码的通用性</h3><p>当我们提交一个功能，或者修复一个问题的时候，很多时候我们只是从这个问题的角度护发，但是并没有从全局的角度出发，例如：</p><ul><li>当我们新增一个上报的时候，有没有考虑把整个上报聚合到一起，或者架构上支持更方便的上报能力？</li><li>当我们新增一个通用能力的时候，有没有考虑到其他模块或项目也可能有类似需求，我们是否可以将其单独抽离成一个独立的包进行分发？</li><li>当我们遇到一个问题有多种修复方案的时候，有没有综合考虑，哪一种方案对后续维护的同学更加友好（比如，最好是高内聚、低耦合的设计）？</li></ul><p>这里的大体原则，就是我们需要从整体性的角度出发，不断地迭代让整个架构更加夯实，而不是出个问题贴一个创可贴，新增功能又贴一个创可贴。</p><h3 id="配置化"><a href="#配置化" class="headerlink" title="配置化"></a>配置化</h3><p>这里的配置化，比较典型的比如是：多语言文案、项目 Settings 配置等。</p><ul><li>一般来说，配置化的内容最好是走云端下发。</li><li>如果不具备云端下发的环境，或者我们的配置<strong>比较敏感不适合直接下发</strong>，可以考虑在代码中创建配置文件的方式。</li></ul><p>如果我们在 Review 中发现有可以配置化的内容但是却直接写死在代码里面了，应当需要提出质疑。</p><h3 id="代码精简"><a href="#代码精简" class="headerlink" title="代码精简"></a>代码精简</h3><p>代码精简对后期的可维护性是非常重要的，代码精简的一个比价有效的办法就是充分理解业务，写出精简不多余的代码，不过这一点在 MR 中可能会比较难进行 Review，因为一般来说提交代码的同学本身是对这部分业务是理解的最透彻的。</p><p>但是有一点代码的 Reviewer 会比较容易判断，如果我们提交的代码里面有两处以上超过三行的极其相似的代码，我们就应当重新审视是否可以进行一定程度的抽离，建议不要由于一时的效率允许不符合规范的代码合入，这些在后期都可能演化成代码屎山。</p><p>Rust 代码精简的一些建议：</p><ul><li>避免任何一次多余的 Clone。</li><li>文件头部引用中去除没有必要的引用。</li><li>避免多余的日志，同时避免在日志里面加太长的前缀内容（有的时候一行日志里面有多半都是元信息，而且这些元信息还是有所重复的）。</li><li>避免多余的 pub，应该有一个理念就是默认的内容不要 pub 出去，就像 c++ 的成员方法默认是 private 一样。</li><li>重复代码使用宏来替代。</li></ul><h2 id="重视性能"><a href="#重视性能" class="headerlink" title="重视性能"></a>重视性能</h2><h3 id="防止泄漏"><a href="#防止泄漏" class="headerlink" title="防止泄漏"></a>防止泄漏</h3><p>在考察性能之前，我们需要保证自己的代码没有泄漏，因为泄漏造成的恶劣性通常比性能差更严重，而且通常需要更长的时间来排查。</p><p>这里主要的检查点可以是：</p><ul><li>addListener 之后是否及时释放了。</li><li>setInterval/setTimeout 等定时器调用是否存在多次调用的可能性，以及是否可能无法释放。</li><li>分配在堆上的内存是否释放了。</li><li>是否有 detach dom 泄漏。</li></ul><h3 id="防止死锁"><a href="#防止死锁" class="headerlink" title="防止死锁"></a>防止死锁</h3><p>这一点如果是前端开发，一般没有机会遇到，但如果你用 rust、c++ 等语言，都很有可能出现死锁的风险（严格来说，死锁并不能直接归类到性能）。</p><p>对于死锁的防止，我建议团队内的基础设施部分先配置好死锁检测和上报机制（例如 parking_lot 提供了死锁检查的能力）。</p><p>一些死锁相关的 Review 建议：</p><ol><li>用到锁的地方，尽可能通过工具函数进行封装，类似 getter 和 setter，增加原子性，减少调用代码直接解锁的场景。</li><li>锁的粒度不应该太大，<strong>我们应该是对数据进行加锁，而不是对过程进行加锁</strong>，锁粒度过大很容易出现死锁的风险。</li><li>在函数脱离控制权之前，例如准备开始调用到其他外部函数了，这个时候最好把持有的锁都释放掉，防止外部函数再次用到造成锁重入。</li></ol><h3 id="性能报告"><a href="#性能报告" class="headerlink" title="性能报告"></a>性能报告</h3><p>关于这一部分，也建议团队基建先行，有一个比较标准的性能测试方法，这样大家在做性能测试的时候，不会那么有压力。比较反对的一种方式就是团队内部不同成员都有自己的一套性能测试方法，这样有些新同学缺乏必要的上下文，自然不了解如何去做性能测试。</p><p>一般来说，我们涉及到比较大的功能都要进行一些性能报告，相关的指标可以是：</p><ol><li>整体包体积的增加幅度。</li><li>初始化响应速度的变化。</li><li>运行该功能一段时间的 CPU 消耗。</li><li>运行该功能一段时间的 内存 消耗。</li><li>运行该功能较长时间的 CPU/内存 消耗。</li></ol><p>不过，具体这一部分还是建议团队内部根据项目的实际情况有一个统一的标准，并且将性能测试方法标准化，而不要成为一个负担。</p><h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>在兼容性这方面，无论是 web 开发还是桌面客户端开发，都需要重点关注，这里其实细分为两个维度：</p><ul><li>版本支持，例如我们可能会实现约定好支持到 Chrome 的哪个版本（针对 web）或者 macOS 的哪个版本（针对 macOS 桌面端），并且如果提交涉及到兼容性改动需要重点测试所支持的最低版本。</li><li>异常情况支持，这一点可能大多数时候都会被大家忽略，这里举一个例子就是 webgl 的支持，实际上，虽然大多数时候浏览器已经支持到了 webgl，但是仍然有不少场景，webgl 会初始化失败，这个原因可能和用户的硬件比如系统显卡有关，如果我们的项目只有 webgl 实现，我们需要考虑是否放弃 webgl 初始化失败的场景（从商业化的角度，一般来说都是希望不要放弃），或者说为此增加软渲染降级。</li></ul><p>所以，在 Code Review 环节，针对可能出现兼容性风险的地方，我们需要确认是否已经进行了兼容性测试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;笔者在日常工作中会发现，时常会存在一些比较显而易见或者已知的一类问题，在开发者提交代码以及相关同学 Review 中均未被发现。实际上，代码开发者在某些时候会提交较多代码，而此时 Reviewer 面对较多代码的 Review 的时候，很可能会漏掉一些 Review 的要点</summary>
      
    
    
    
    
    <category term="编程综合" scheme="http://niexiaotao.cn/tags/%E7%BC%96%E7%A8%8B%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>web 页面内存分析与生产环境禁用 console</title>
    <link href="http://niexiaotao.cn/2021/09/04/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%A6%81%E7%94%A8console%E7%9A%84%E6%84%8F%E4%B9%89/"/>
    <id>http://niexiaotao.cn/2021/09/04/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E7%A6%81%E7%94%A8console%E7%9A%84%E6%84%8F%E4%B9%89/</id>
    <published>2021-09-04T11:15:01.000Z</published>
    <updated>2022-04-13T07:07:01.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们在开发前端页面中，建议在生产环境中将所有的 console 禁用，并通过自定义的日志函数进行日志输出，即使无法禁用，也需要自定义文本过滤函数，严格控制 console 的输出。</p><p>但实际上，笔者经历的项目中很多都没有办法做到这一点，虽然我们知道，禁用 console 的主要原因除了信息泄漏的风险外，还有就是 console 打印的内容无法被内存回收。但仍然总是会有一些同学对禁用 console 的必要性表示质疑，在本篇文章中，本文通过两个实际遇到的比较严重的例子，来解释禁用 console 的必要性。</p><blockquote><p>出于保密性考虑，例子本身已经脱敏，本文使用示例代码模拟原始场景。</p></blockquote><h2 id="页面内存"><a href="#页面内存" class="headerlink" title="页面内存"></a>页面内存</h2><p>在具体例子讲解之前，我们需要先对页面内存有一个认知，在前端开发中，我们虽然开发的只是在 Chrome 等浏览器中浏览的页面，但是对页面的 cpu 和 内存占用也需要时刻保持关注。</p><p>cpu 和 内存一般是针对进程级别，chrome 的进程模型比较复杂，一般情况下，我们可以认为同域的页面有比较大的概率进行进程复用。</p><p>Chrome 提供了一些手段，让我们可以监控页面的 cpu 和内存，例如：</p><p>Performance Monitor 可以让我们直观地监测页面的 cpu、js heap 的分配情况等：</p><p><img src="/img/chrome_monitor.png" alt="chrome_monitor"></p><p>Chrome 自身提供了一个任务管理器（More Tools -&gt; Task Manager），可以让我们关注各个页面的性能情况：</p><p><img src="/img/chrome_task_manager.png" alt="chrome_task_manager"></p><p>除了实时监控以外，Chrome DevTools 的 Memory 等 tab 也可以让我们对内存占用进行取样分析，以及内存泄漏分析：</p><ul><li>一般来说，我们可以通过对两次 heap snapshot，然后搜索关键变量的数目与引用关系是否符合预期，来证明是否存在内存泄漏。</li><li>除此之外，我们使用 WeakMap 来跟踪我们的实例，也可以辅助进行一定的内存泄漏分析。</li></ul><h2 id="使用-console-log-打印-dom-元素造成死循环-OOM"><a href="#使用-console-log-打印-dom-元素造成死循环-OOM" class="headerlink" title="使用 console.log 打印 dom 元素造成死循环 OOM"></a>使用 console.log 打印 dom 元素造成死循环 OOM</h2><p>之前笔者负责的一个页面，在某个版本出现了一个问题：打开页面后不久，在什么操作也没有做的情况下直接卡死无响应。</p><p>一般来说，js 导致网页无响应的可能性并不多，我们首先怀疑是因为死循环导致的。</p><p>不过我们通过对比上次和这一次的代码，发现变动极小（实际上，我们一开始都忽略了 console.log），我们通过在 Chrome 的 devTools 里面打断点，最终定位发现是卡死在第三方库 sentry 的 console.log 中。</p><p>最终我们定位出真正的原因：其中一处 try catch 在 catch 到错误之后，会 console.log 打印包括 dom 在内的一些内容，而我们使用的 console.log 被 sentry 进行了覆盖，它的覆盖方法大致如下（这个确实有点坑，以至于我们直接查看 console.log 仍然是 [native code]， 不过最新版本的 Chrome 这个代码已经不能完全 work）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> __native_console = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归遍历各个属性</span></span><br><span class="line">  __native_console(...arguments);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log.prototype.__native_console = __native_console;</span><br><span class="line"><span class="built_in">console</span>.log.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.__native_console) <span class="keyword">return</span> <span class="built_in">this</span>.__native_console.toString();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 2021.09 @niexiaotao 补充一下最新的实现</span></span><br></pre></td></tr></table></figure><p><strong>这里之所以死循环，是因为 React 中 FiberNode 是 Dom 的其中一个属性，console.log 递归遍历到了 FiberNode，其本质是一个双向链表，最终造成无限递归死循环</strong>。</p><p>我们可以比较方便的随便找个 React 项目验证这一点：</p><p><img src="/img/chrome_fiber.png" alt="React Fiber"></p><h2 id="detached-dom-过多导致页面内存持续上涨"><a href="#detached-dom-过多导致页面内存持续上涨" class="headerlink" title="detached dom 过多导致页面内存持续上涨"></a>detached dom 过多导致页面内存持续上涨</h2><p>另外笔者接触到的一个比较严重的问题，是之前某项目的一个页面，随着使用时间增加，页面的内存使用量快速持续增加，最终导致卡顿和崩溃。</p><p>这个问题的定位过程也比较艰辛，最终发现其中的一个主要原因是 <strong>console.log 打印了 dom 节点，导致 detached dom 持续增多并且无法被回收，最终导致严重问题</strong>。</p><p>关于 detached dom 的问题我们可以使用<a href="http://niexiaotao.cn/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/">通过压缩合成层优化性能</a> 这里的 demo，简单修改：</p><p>将原本需要挂载到 dom 的节点直接进行打印：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; totalListCount; i += <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span><br><span class="line">  fragment.classList.add(<span class="string">&quot;li&quot;</span>);</span><br><span class="line">  fragment.innerHTML = <span class="string">`&lt;p&gt;this is the <span class="subst">$&#123;i&#125;</span> element&lt;/p&gt;`</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(fragment);</span><br><span class="line">  <span class="comment">// list.appendChild(fragment);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们很容易看到这样就产生了 500 个 detach 节点，并且在页面的生命周期内，无法进行释放：</p><p><img src="/img/chrome_detach_console.png" alt="detach console"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实际上，在生产环境使用 console.log 造成的问题远不止上面的两例，而且这类问题通常排查起来都会比较艰难，因此，建议大家落实在生产环境禁用 console。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们在开发前端页面中，建议在生产环境中将所有的 console 禁用，并通过自定义的日志函数进行日志输出，即使无法禁用，也需要自定义文本过滤</summary>
      
    
    
    
    
    <category term="javascript" scheme="http://niexiaotao.cn/tags/javascript/"/>
    
    <category term="性能优化" scheme="http://niexiaotao.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>通过优化合成层优化性能</title>
    <link href="http://niexiaotao.cn/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/"/>
    <id>http://niexiaotao.cn/2021/09/04/%E9%80%9A%E8%BF%87%E5%8E%8B%E7%BC%A9%E5%90%88%E6%88%90%E5%B1%82%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/</id>
    <published>2021-09-04T05:15:01.000Z</published>
    <updated>2022-04-13T07:07:01.197Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Web 性能优化特别是长列表滚动优化是一个老生常谈的问题，一般我们的思路是通过虚拟滚动、GPU 加速、fragment 复用等方式优化性能。</p><p>在本篇文章中，主要介绍一个压缩合成层的思路来进行性能优化，关于合成层的文章网上也有一些（附录部分有列出），不过大部分文章会对合成层创建的原因进行冗长的介绍，本文会跳过这些部分。原因是我们通过 devTools 可以比较方便的针对具体情况分析创建合成层的原因，另外一个原因是 blink 已经把创建合成层的原因写到了一个文件中（<a href="https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/platform/graphics/compositing_reasons.cc">传送门</a>），我们直接参考就行，也没有必要去全都记住。</p><h2 id="合成层是什么"><a href="#合成层是什么" class="headerlink" title="合成层是什么"></a>合成层是什么</h2><p>对于 blink 渲染引擎的渲染流程，大致可以分为以下几个阶段：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">D<span class="function"><span class="title">om</span> Tree -&gt;</span> L<span class="function"><span class="title">ayout</span> Object -&gt;</span> P<span class="function"><span class="title">aint</span> Layer -&gt;</span> G<span class="function"><span class="title">raphics</span> Layers Tree -&gt;</span> Paint</span><br></pre></td></tr></table></figure><p>我们对以上过程进行一个简述：</p><ul><li>Dom Tree 到 Render Tree 这个过程，基本是一一对应的，除了一些 display:none 的元素。</li><li>Layout Object 会按照一定条件创建 Paint Layer。</li><li>Paint Layer 在到 Graphics Layer 的过程中，会创建合成层（Composite Layer），会对应独立的 Graphics Layer。</li><li>Graphics Layer 会把结果渲染到纹理，最终通过 Chrome 的渲染层以及系统进行上屏。</li></ul><p>实际上我们可以发现，合成层的多少会比较影响我们的渲染性能，合成层比较多的情况下，当我们对页面进行交互（比如滚动），触发重新渲染，就会有卡顿的风险。</p><h2 id="分析合成层"><a href="#分析合成层" class="headerlink" title="分析合成层"></a>分析合成层</h2><p>Chrome 的 DevTools 工具可以让我们比较方便地进行合成层分析，例如我们通过一个 demo 来进行分析：</p><p><img src="/img/composite_reason.png" alt="合成层示例"></p><p>在上图中，我们会发现这个 demo 的合成层比较多，我们点进去可以查看到是因为 overflow 导致创建了新的合成层。</p><p>也就是说，对该 demo 而言我们可以尝试在这些 Demo 中去掉或者修改 overflow 的相关设置，从而进行合成层优化。</p><h2 id="优化合成层"><a href="#优化合成层" class="headerlink" title="优化合成层"></a>优化合成层</h2><p>我们尝试去掉 <code>overflow: scroll;</code>。（ Demo 源代码会在本文最后给出）</p><p>然后我们设置页面的列表元素为 500 个，通过模拟页面持续滚动，来检查去掉前后的性能。</p><p>去掉前，cpu 保持在 50%+，这实际上已经是一个比较高的数值了：</p><p><img src="/img/composite_cpu_1.png" alt="合成层cpu"></p><p>去掉后，cpu 保持在 2% 左右：</p><p><img src="/img/composite_cpu_2.png" alt="去除合成层cpu"></p><p>我们可以看到，优化后有巨大的性能提升，这种量级的性能提升，会远超虚拟滚动等方案（其实我个人是不建议采用虚拟滚动的，非常难维护，而且你很难做到浏览器原生滚动的丝滑水准）。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>示例代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0,minimal-ui:ios&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span> &gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100vw</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100vh</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">      <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">      <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.list</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">90vh</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>: scroll;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.li</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">50px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-bottom</span>: <span class="number">2px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-style</span>: solid;</span></span><br><span class="line"><span class="css">      <span class="attribute">border-color</span>: grey;</span></span><br><span class="line"><span class="css">      <span class="comment">/* overflow: scroll; */</span></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> totalListCount = <span class="number">500</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> list = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.list&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; totalListCount; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createElement(<span class="string">&quot;div&quot;</span>);</span></span><br><span class="line"><span class="javascript">    fragment.classList.add(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="javascript">    fragment.innerHTML = <span class="string">`&lt;p&gt;this is the <span class="subst">$&#123;i&#125;</span> element&lt;/p&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    list.appendChild(fragment);</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> curr = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> renderScroll = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    curr += <span class="number">5</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (curr &gt;= totalListCount) curr = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    list.children[curr].scrollIntoView();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.requestAnimationFrame(renderScroll)</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript">  renderScroll();</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li>Compositing Layers: <a href="https://zhuanlan.zhihu.com/p/88288584">https://zhuanlan.zhihu.com/p/88288584</a></li><li>前端性能优化之 Composite: <a href="https://segmentfault.com/a/1190000015917498">https://segmentfault.com/a/1190000015917498</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;Web 性能优化特别是长列表滚动优化是一个老生常谈的问题，一般我们的思路是通过虚拟滚动、GPU 加速、fragment 复用等方式优化性能。</summary>
      
    
    
    
    
    <category term="性能优化" scheme="http://niexiaotao.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>了解 StackOverFlow 上面最受欢迎的语言 Rust</title>
    <link href="http://niexiaotao.cn/2021/09/02/%E4%BA%86%E8%A7%A3%20StackOverFlow%20%E4%B8%8A%E9%9D%A2%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E8%AF%AD%E8%A8%80%20Rust/"/>
    <id>http://niexiaotao.cn/2021/09/02/%E4%BA%86%E8%A7%A3%20StackOverFlow%20%E4%B8%8A%E9%9D%A2%E6%9C%80%E5%8F%97%E6%AC%A2%E8%BF%8E%E7%9A%84%E8%AF%AD%E8%A8%80%20Rust/</id>
    <published>2021-09-02T11:15:51.000Z</published>
    <updated>2022-04-13T07:07:01.191Z</updated>
    
    <content type="html"><![CDATA[<p>本文希望从宏观角度，来介绍和分析 Rust 语言。</p><p>Rust 是一门<strong>专注安全</strong>的现代系统编程语言，发布于 2015 年。</p><p>自从 2015 年发布起，Rust 就一直是 StackOverFlow 上面最受欢迎的语言，而且和第二名还能拉开不小的差距，例如最近两年的统计数据：</p><p><a href="https://insights.stackoverflow.com/survey/2020#most-loved-dreaded-and-wanted">2020</a>:<br><img src="/img/rust_2020.png" alt="2020_rust"></p><p><a href="https://insights.stackoverflow.com/survey/2021#most-loved-dreaded-and-wanted-language-love-dread">2021</a>:<br><img src="/img/rust_2021.png" alt="2021_rust"></p><p>接下来笔者通过性能、可靠性、生产力、面向前端友好等几个维度来介绍 Rust，之后会对 Rust 的部分重点语言特性进行介绍。</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>首先作为一种编译型语言，可以直接将编译产物作为二进制可执行文件部署，无需随程序一起分发解释器和大量的依赖项，因此相对于 Python、Ruby 以及 Javascript 等解释型语言，会效率更高。</p><p>同时，Rust 提供了大量的零成本抽象（如泛型、async/await、迭代和闭包等），在保证开发效率的同时避免了运行时开销。</p><p>一般来说，Rust 的性能和 C/C++ 相似，无虚拟机，无 GC，运行时仅依赖 libc，<strong>在需要高性能场景中使用已经足够</strong>。</p><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>在一个 c++ 项目中，我们经常会遇到各类 crash，处理这些 crash 通常会花费大量的人力。</p><p>而在一个 Rust 项目中，如果规范使用基本上在编译阶段就可以避免几乎所有的 crash，也就是说，<strong>使用 Rust 的项目只要编译通过，就只有逻辑错误，不会再有 crash</strong>（自身使用了 unsafe 除外）。</p><p>Rust 之所以能做到这一点，得益于其设计的所有权、生命周期、Option 机制以及智能指针等，这一点我们在下文的语言特性中也会更详细地分开介绍。</p><blockquote><p>实际上，笔者现在负责的项目中 Rust 和 C++ 大约各有一半的代码，在这其中 Rust 几乎没有出现过 crash，而 c++ 基本上每双周（一个迭代）都会新增一些种类的 crash。</p></blockquote><h2 id="生产力"><a href="#生产力" class="headerlink" title="生产力"></a>生产力</h2><h3 id="代码开发效率"><a href="#代码开发效率" class="headerlink" title="代码开发效率"></a>代码开发效率</h3><p>得益于 Rust 的大量零成本抽象，以及 Rust 提供的高度灵活的宏机制，我们的代码开发效率还是比较高的。就笔者的体验而言，使用 Rust 完成功能的开发效率略低于 Typescript，但是远高于 c++（和 Typescript 相比，Rust 通常会需要花费额外的一些时间来解决编译问题，但是换来的是高性能和稳定性，我认为这是值得的）。</p><p>另外随着 Rust 语言的逐渐成熟，配套的 IDE 和编辑器（Clion、VSCode）也逐渐成熟，日常代码开发提示、以及代码调试等都非常方便。</p><h3 id="包管理系统"><a href="#包管理系统" class="headerlink" title="包管理系统"></a>包管理系统</h3><p>另外值得一提的是，Rust 的包管理系统非常强大，这一点我认为 Rust 也参考了 npm，包管理系统的使用体验也和 npm 比较接近，新增一个依赖，只需要在 Cargo.toml 配置文件中新增一行配置即可。方便的包管理系统，让我们可以方便地复用<a href="https://crates.io/">社区各类优秀的资源</a>。</p><p>相对来说，c++ 这类老牌语言的包分发和管理就会麻烦很多，甚至在一个项目内也会比较麻烦。</p><h3 id="现有资源的复用"><a href="#现有资源的复用" class="headerlink" title="现有资源的复用"></a>现有资源的复用</h3><p>这一点主要是 Rust 和 C/C++ 的互相调用，Rust 支持调用 C 接口和封装成 C 接口被其他语言所调用，因此对于现有的项目，如果可以提供一层 C 接口的封装，就会比较方便地被 Rust 直接调用。</p><h2 id="面向前端友好"><a href="#面向前端友好" class="headerlink" title="面向前端友好"></a>面向前端友好</h2><p>我认为 Rust 面向前端友好主要体现在两个方面：</p><h3 id="虽然学习路线陡峭，但和-Typescript-相近点较多"><a href="#虽然学习路线陡峭，但和-Typescript-相近点较多" class="headerlink" title="虽然学习路线陡峭，但和 Typescript 相近点较多"></a>虽然学习路线陡峭，但和 Typescript 相近点较多</h3><p>很多人劝退 Rust 理由之一是其学习曲线陡峭，但是实际上前端同学学习 Rust 会比学习 C++ 容易的多，一方面，Rust 的很多机制（async/await、类的设计、包管理）等都和 Typescript 有相似之处，另外一方面写 Rust 只要编译能够通过基本上能够保证你代码质量的下限，也就是说基本上可以上线生产环境。而 C++ 新手写出来的代码通常会有各种 crash 隐患，而且排查通常较为困难，导致容易背锅，这一点来说对新手非常不友好。</p><h3 id="面向-WASM-友好"><a href="#面向-WASM-友好" class="headerlink" title="面向 WASM 友好"></a>面向 WASM 友好</h3><p>对于 WebAssembly，笔者并不推荐 AssemblyScript，因为其虽然是 “Typescript”，但是使用起来和 Typescript 相差太多，而且无法完全直接使用 JavaScript 的第三方库，调试等也并不是很方便。</p><p>而剩余的几类语言中（Rust、C++、Kotin、Golang），相对来说 Rust 和 C++ 的 wasm 编译都较为成熟，Rust 更是在设计之初即考虑支持 WebAssembly 并且将其作为一个主要亮点，被 Rust 官方团队直接维护（包含了勤劳的 Alex Crichton，其也是 tokio 的作者）。因此我们使用 Rust 编译 WebAssembly 非常方便，并且可以直接使用大多数第三方 Rust 库，使用体验和 Rust Native 开发基本上没有差异。</p><p>目前笔者的项目中，有一部分模块即使用了 Rust + WebAssembly，同时支持了 Windows/Mac/iOS/Android/Web 五种平台，并且几乎都做到了最高性能。</p><blockquote><p>当然不得不承认，Rust 编译 WebAssembly 在使用到 C++ 的资源时也并不是十分方便，Rust 的 WASM 编译器和 Emscripten 也有诸多差异，适配起来会比较头疼，如果现有项目主要是 C++，还是建议直接使用 Emscripten。</p></blockquote><h2 id="重点语言特性"><a href="#重点语言特性" class="headerlink" title="重点语言特性"></a>重点语言特性</h2><p>Rust 拥有大多现代语言具备的特性，比如 RAII、动态数据类型等，另外还有不少设计是 Rust 中独有的，下面我们对一些 Rust 中比较独特的语言特性进行一些介绍。</p><h3 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h3><p>Rust 的所有权机制，即一个值同一个时刻只能被一个变量所引用，我们来看一个简单的例子：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;hello&quot;</span>.<span class="keyword">to</span><span class="constructor">_string()</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">println!(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a); <span class="comment">// 提示报错：value borrowed here after move</span></span><br></pre></td></tr></table></figure><p>因为我们把 a 对应的数据的所有权给到了 b，也就是说 a 不再拥有对应的数据的所有权，因此也无法访问，<strong>这种机制保证了数据安全，能够有效避免悬垂指针的发生</strong>。</p><p>当然，对于实现了 Copy（一般来说，都是存储在栈上面的简单数据类型），在赋值阶段会自动拷贝，或者对于没有实现 Copy，但是实现了 Clone（需要主动调用）的类型我们显式调用 Clone，都可以编译通过，这些设计给我们的日常开发中带来了极大的便利：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">i32</span> = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a); <span class="comment">// pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">&quot;hello&quot;</span>.to_string();</span><br><span class="line"><span class="keyword">let</span> b = a.clone();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;a: &#123;:?&#125;&quot;</span>, a); <span class="comment">// pass</span></span><br></pre></td></tr></table></figure><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>在 Rust 中，一般情况下并没有空指针的概念，并不像 c++ 有 nullptr、java 有 null，Rust 中如果表示一个可空的内容只能使用 Option（有点类似 C++ 的 std::optional）。</p><p>除了 Option，Rust 还封装了若干种高级指针，并对不同类型的指针的行为进行限制，以提高其安全性：</p><ul><li>Box：用于在堆上存储数据，<strong>单一所有权</strong>（即一般情况下不会存在一个指针乱飞的情况），可以用于封装在编译时未知大小的类型。</li><li>Rc：引用计数指针，不支持多线程</li><li>Arc：多线程版本的引用计数指针</li><li>RefCell：保持内部可变性的指针，即我们如果希望多个所有者共同拥有并且都可以修改的指针，需要结合 Rc 或 Arc 加 RefCell 一起使用。‘</li></ul><p>Rust 还提供了一些其他类型的智能指针，在这里不再过多介绍，虽然这里的大部分概念 c++ 也存在，但是 Rust 基本只能是强制你使用这些内容，而无法使用不安全的裸指针。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>Rust 中的多态有基于泛型的静态派发和基于 trait 的动态派发。</p><ul><li>静态派发：是一种零成本抽象，在 C++ 中也有类似的概念，静态派发是通过对不同类型的调用在编译期间生成不同版本的代码来实现的，不会引入运行时开销（但请注意可能会造成代码体积膨胀）。</li><li>动态派发：有些场景下，我们没有办法在编译期间确定变量的实际类型，进而无法确定其占用内存大小，Rust 也提供了 trait 机制来实现动态派发，同时 Rust 将此类 trait 使用 dyn 进行显式指定：</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态派发：</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Speak</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span></span>;</span><br><span class="line"><span class="keyword">impl</span> Speak <span class="keyword">for</span> Human &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;hello, I am a Human&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_hello</span></span>(someone: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> Speak&gt;) &#123;</span><br><span class="line">    someone.hello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> human = Human &#123;&#125;;</span><br><span class="line">    test_hello(<span class="built_in">Box</span>::new(human));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>Rust 中的宏的能力非常强大，其不同于 C/C++ 中的宏简单地按字符串替换代码，而是基于语法树进行操作，在编译阶段被展开成源代码进行嵌入。</p><p>具体 Rust 中的宏也分为声明宏和过程宏，能够实现的需求非常多样，在一个大型项目中，我们可以通过宏的使用解放生产力，并且使代码更清晰。不过，宏这一部分的具体学习相对比较复杂，在这里便不再进行举例。</p><hr><p>综合来说，Rust 作为一个比较先进的语言，没有太多的历史包袱，从各个语言中吸收了不少的优质特性，比较适合我们在新项目的技术选型中作为一个考虑因素。</p><h2 id="如何开始学习-rust"><a href="#如何开始学习-rust" class="headerlink" title="如何开始学习 rust"></a>如何开始学习 rust</h2><h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><p>rust 本身的文档和学习资料官方提供的比较全面，一个必读的内容是<a href="https://doc.rust-lang.org/book/">“The Rust Programming Language”</a>。</p><p>不过，rust 的官方文档读起来可能略有枯燥，这个时候我建议可以先开始读<em>张汉东</em>的《Rust 编程之道》，相对来说更加深入浅出，不过还是后续还是建议读一遍文档。</p><h3 id="项目应用"><a href="#项目应用" class="headerlink" title="项目应用"></a>项目应用</h3><p>在我们将上述内容读完之后（如果每天两个小时的话，大约需要一个月的时间），具备了一定的 Rust 语言基础，可能需要思考下如何在现有项目中落地，我个人的一个建议是：</p><ul><li>如果现有项目是偏 web 的，可以先考虑通过 wasm 来落地，相对来说上手成本很低，我之前也对<a href="https://zhuanlan.zhihu.com/p/104299612">入门 Rust 开发 WebAssembly</a>有所总结。</li><li>如果现有项目是偏 native 的，可以考虑将部分新模块、或者 crash 告警比较多的逻辑部分，使用 rust 实现并且通过 C FFI 和现有模块进行交互，渐进式引入 Rust 技术栈。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文希望从宏观角度，来介绍和分析 Rust 语言。&lt;/p&gt;
&lt;p&gt;Rust 是一门&lt;strong&gt;专注安全&lt;/strong&gt;的现代系统编程语言，发布于 2015 年。&lt;/p&gt;
&lt;p&gt;自从 2015 年发布起，Rust 就一直是 StackOverFlow 上面最受欢迎的语言</summary>
      
    
    
    
    
    <category term="Rust" scheme="http://niexiaotao.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>一些性能相关的 JavaScript 代码编写建议规范</title>
    <link href="http://niexiaotao.cn/2021/08/29/%E4%B8%80%E4%BA%9B%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%20JavaScript%20%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE%E8%A7%84%E8%8C%83/"/>
    <id>http://niexiaotao.cn/2021/08/29/%E4%B8%80%E4%BA%9B%E6%80%A7%E8%83%BD%E7%9B%B8%E5%85%B3%E7%9A%84%20JavaScript%20%E4%BB%A3%E7%A0%81%E7%BC%96%E5%86%99%E5%BB%BA%E8%AE%AE%E8%A7%84%E8%8C%83/</id>
    <published>2021-08-29T05:59:00.000Z</published>
    <updated>2022-04-13T07:07:01.190Z</updated>
    
    <content type="html"><![CDATA[<p>本文对一些日常编写 JavaScript 的过程中，一些有助于提高代码性能的规范进行罗列。</p><blockquote><p>本文比较零碎，不作为规范提议，仅作为交流参考。</p></blockquote><h3 id="1-使用解构赋值，减少中间变量。"><a href="#1-使用解构赋值，减少中间变量。" class="headerlink" title="1. 使用解构赋值，减少中间变量。"></a>1. 使用解构赋值，减少中间变量。</h3><p>对于一些比如变量替换的场景，我们使用解构赋值，可以省略中间变量，整体代码也会更加清晰。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">a</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span> = <span class="number">4</span>;</span><br><span class="line">[b, a] = [a, b];</span><br></pre></td></tr></table></figure><h3 id="2-通过条件判断提前返回"><a href="#2-通过条件判断提前返回" class="headerlink" title="2. 通过条件判断提前返回"></a>2. 通过条件判断提前返回</h3><p>这里主要是提醒大家如何写好 if 语句。</p><p>实际上， 在编写复杂的 if 语句之前，我们应该考虑是否可以<strong>逻辑外化</strong>：</p><p>即尽可能的将代码的复杂逻辑向外推，例如抽离成多个函数，而不是在程序里面进行过多判断。有一种比较典型的不合理的重用是把大量的逻辑都堆叠到一个函数里面，然后提供一个很复杂的功能。我认为更好的做法应当是分离成更多的模块。</p><p>经过以上思考之后，我们可能还有一些 if 语句，一般的原则是：</p><ul><li>if 语句先简单，后复杂。</li><li>if 语句，可以提前返回即提前返回，减少复杂的嵌套。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> nice:</span><br><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">  <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">  <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">other_function();</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> bad:</span><br><span class="line"><span class="keyword">if</span> (condition1) &#123;</span><br><span class="line">  <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">do</span> something</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    other_function();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-尽量避免在循环体内包裹函数表达式"><a href="#3-尽量避免在循环体内包裹函数表达式" class="headerlink" title="3. 尽量避免在循环体内包裹函数表达式"></a>3. 尽量避免在循环体内包裹函数表达式</h3><p>函数表达式会生成对应的函数对象，如果我们在循环体内去做这个事情，很可能会造成额外的浪费。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// nice:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> len = nodelist.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">1</span>) &#123;</span><br><span class="line">  addListener(nodelist[i], callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad:</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nodelist.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">  addListener(nodelist[i], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-对循环体内的不变值，在循环体外使用缓存"><a href="#4-对循环体内的不变值，在循环体外使用缓存" class="headerlink" title="4. 对循环体内的不变值，在循环体外使用缓存"></a>4. 对循环体内的不变值，在循环体外使用缓存</h3><p>这一条其实是对上一条的补充，实际上是同样的原理，即希望我们在循环体内尽量保持逻辑的简单，减少重复的 cpu 时间和内存的消耗。</p><h3 id="5-清空数组使用-length-0"><a href="#5-清空数组使用-length-0" class="headerlink" title="5. 清空数组使用 .length = 0"></a>5. 清空数组使用 .length = 0</h3><p>这样写可以方便我们清空一个 const 数组。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 如果使用 a = [] 会报错</span></span><br><span class="line">a.<span class="built_in">length</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="6-不得为了编写方便，将并行的-io-串行化"><a href="#6-不得为了编写方便，将并行的-io-串行化" class="headerlink" title="6. 不得为了编写方便，将并行的 io 串行化"></a>6. 不得为了编写方便，将并行的 io 串行化</h3><p>虽然现在 JavaScript 有了 async/await，但是我发现很多同学会对此滥用，一个很常见的清空就是将可以并行的操作串行化了:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let</span> res<span class="number">1</span> = await process<span class="number">1</span>();</span><br><span class="line"><span class="attribute">let</span> res<span class="number">2</span> = await process<span class="number">2</span>();</span><br><span class="line"><span class="attribute">next</span>(res<span class="number">1</span>, res<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这个时候，虽然写代码方便，但是这样写是不可取的，Promise 提供了若干的方便我们处理并行任务的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise#">方法</a>，我认为这些都是必须要了解的。</p><h3 id="7-禁止直接使用-eval"><a href="#7-禁止直接使用-eval" class="headerlink" title="7. 禁止直接使用 eval"></a>7. 禁止直接使用 eval</h3><p>eval 的安全性非常差，事实上有很多已知的 xss 等漏洞都和 eval 有关，所以我们在实际场景中避免使用 eval。</p><p>如下为一个例子，使用了 eval 函数，由于其执行代码的作用域为本地作用域，所以对我们的本地变量进行了修改并且可以生效：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">tip</span> = <span class="string">&quot;请重新登录&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="attr">otherCode</span> = `<span class="attr">tip</span> = <span class="string">&quot;请前往 xxx.com 重新登录&quot;</span>`</span><br><span class="line">eval(otherCode);</span><br></pre></td></tr></table></figure><p>一些取代方式：</p><p>我们可以使用 <code>new Function</code> 的方式来代替 eval，这样至少可以进行作用域的隔离，相对会安全一些（但是请注意其仍然会可能影响到全局变量）。</p><h3 id="8-浏览器环境中，尽量避免使用-document-all、document-querySelectorAll"><a href="#8-浏览器环境中，尽量避免使用-document-all、document-querySelectorAll" class="headerlink" title="8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll"></a>8. 浏览器环境中，尽量避免使用 document.all、document.querySelectorAll</h3><p>类似的 all 相关操作都要避免使用，由于我们很难控制随着项目发展内容会有多少，所以我们最好一开始就不要留下随着项目内容增加性能越来越差的隐患。</p><h3 id="9-获取元素的样式，尽量使用-getComputedStyle-或-currentStyle"><a href="#9-获取元素的样式，尽量使用-getComputedStyle-或-currentStyle" class="headerlink" title="9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle"></a>9. 获取元素的样式，尽量使用 getComputedStyle 或 currentStyle</h3><p>通过 style 只能获得内联定义或通过 JavaScript 直接定义的样式，通过 CSS class 设置的样式无法直接获取。</p><h3 id="10-尽可能通过为元素添加预定义的-ClassName-来改变元素样式，避免直接操作-style-进行设置。"><a href="#10-尽可能通过为元素添加预定义的-ClassName-来改变元素样式，避免直接操作-style-进行设置。" class="headerlink" title="10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。"></a>10. 尽可能通过为元素添加预定义的 ClassName 来改变元素样式，避免直接操作 style 进行设置。</h3><p>直接操作 style，会比较混乱，而且有的时候还会忘记写单位，导致实际上不管用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文对一些日常编写 JavaScript 的过程中，一些有助于提高代码性能的规范进行罗列。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文比较零碎，不作为规范提议，仅作为交流参考。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;1-使用解构赋值，减少中间变量。&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="javascript" scheme="http://niexiaotao.cn/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>如何让你的精力更多的用于提高技术深度</title>
    <link href="http://niexiaotao.cn/2021/07/26/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%B2%BE%E5%8A%9B%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%94%A8%E4%BA%8E%E6%8F%90%E9%AB%98%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6/"/>
    <id>http://niexiaotao.cn/2021/07/26/%E5%A6%82%E4%BD%95%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%B2%BE%E5%8A%9B%E6%9B%B4%E5%A4%9A%E7%9A%84%E7%94%A8%E4%BA%8E%E6%8F%90%E9%AB%98%E6%8A%80%E6%9C%AF%E6%B7%B1%E5%BA%A6/</id>
    <published>2021-07-26T15:42:20.000Z</published>
    <updated>2022-04-13T07:07:01.194Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/395177123">知乎版本</a></p><p>题目所述，就是我最近很久一段时间都在用来思考的问题。</p><p>先说下个人的背景，目前已经毕业三年，第一年主要做前端开发，大约在两年前，我的主要精力从前端转向了 Rust，而后又开始在公司参与开发 c++。</p><p>在这三年里面，自己持续面临着一个问题，这个问题就是，如何从一个繁忙而重复的工作中，持续提升自己的技术深度。</p><p>因为我发现，当在一个公司久了以后，随着参与的业务增多，问题和 OnCall 也随之增多，另外随着你对业务的熟悉，会有越来越多的新同学向你问问题。处理这些问题会占据越来越多的精力。当然，如果你比较“幸运”中途业务黄掉或架构彻底变化了，你去参与新的项目，有可能能获得一次接近重新开始的机会，但大多数时候，你可能都没有这么幸运。</p><p>当这些问题处理的久了以后，你会发现甚至连完成工作都需要加班来解决，就更没有时间来进行技术的提升了，长此以往，焦虑感便倍增。</p><p>不过，最近我在思考这些问题的过程中，也渐渐总结了一些缓解的办法，接下来便和大家进行分享。</p><p><strong>这里的核心点在于，减少犯错误的机会，提高处理问题的效率，释放出自己的更多时间</strong></p><h2 id="1-提高对代码的要求，写更好的代码"><a href="#1-提高对代码的要求，写更好的代码" class="headerlink" title="1. 提高对代码的要求，写更好的代码"></a>1. 提高对代码的要求，写更好的代码</h2><p>我最近处理的众多问题，粗略估算，有大约 1/3 都是由于开发者代码水平不足带来的技术债务（即代码逻辑错误、边界情况未考虑、性能与稳定性不足等）。</p><p>我这里主要针对的是 PC 客户端，还有很多问题和特殊机器、其他模块干扰项、硬件驱动等关系密切，如果是纯前端项目，这个比例只会更高。</p><p>因为写代码的时候，并没有采用最合理的方式，导致有出现问题的隐患，如果你的问题出现的概率比较高，大概率会比较幸运地较早发现，但如果出现的概率低，甚至灰度阶段都没有暴露，那么当初几行代码的问题，会让自己之后花加倍的时间来去处理，甚至还可能面临更多后果。</p><p>那么，如何让自己写出更好的代码呢，我认为可以做到以下几点：</p><ul><li><strong>请熟读文档</strong>，比如如果是在开发 Vue 项目，那么请至少把 Vue 的文档看一遍，React 同理，这样你会更加清楚，框架到底提供了那些能力，什么时候使用更合适的 API 来完成一个目标。</li><li>注重注释，对于一些特殊处理的情况，注释是很有必要的，最好附上文档，否则可能时间久了，自己都不知道为什么这样去处理，会让修复问题花费更多的时间。</li><li>除非迫不得已，不要提交带有已知优化项的代码，例如重复代码并没有完全处理、代码在某些情况还可能造成问题。时间允许的情况下，一步到位，通常比分两次到位能节约更多的时间，至少能节约一次测试的时间，另外大脑的上下文切换还有开销。</li><li>CI/CD 的建设，保证合并的代码是能够编译的。</li><li>对于前端来说，全部采用 Typescript，使用 ESLint 约束代码，<strong>禁止</strong>直接使用 JavaScript。</li><li>团队需要建立 Review 机制，并且对 Review 过程负责。对于别人提交 Review 的代码至少需要通读一遍，避免基本的错误。</li></ul><h2 id="2-日志是语言的另一面，也很能体现代码水平"><a href="#2-日志是语言的另一面，也很能体现代码水平" class="headerlink" title="2. 日志是语言的另一面，也很能体现代码水平"></a>2. 日志是语言的另一面，也很能体现代码水平</h2><p>这里的日志，指的是在用户使用过程中，实时上传的的或者离线的日志。</p><p>这里单独提一点日志，是因为在实际中，我们大约有一半时间在写代码，而另外一半时间在查问题，那么为什么就不能好好写日志呢？</p><p>“日志不足/没打日志，需要加日志进一步定位”。</p><p>不知道你在 OnCall 的过程中，是否遇到过此类回复，当然并不能说每次这样的问题都是开发者水平不足导致日志不全，但的确有很多情况是我们可以提前规避的。</p><p>那么一个好的日志应该是什么样的呢？</p><ol><li>前提：废话不要多，能简写就简写，这是因为一般日志都是存在用户本地的，日志量比较大的情况下会影响用户的硬盘占用，当然日志本身的打印也是消耗 CPU 的。</li><li>关键路径的日志要有，可能出问题的地方不要存在侥幸心理，把日志打全，特别是<strong>不同负责模块之间衔接的日志，一定打全</strong>，这样之后甩锅的时候有实锤也会方便一点。</li><li>关键日志需要有关键字，方便后面自动化分析，毕竟，对于一个比较完善的项目而言，机器人分析日志甚至比人分析更为靠谱。</li><li>日志也需要<strong>向前兼容</strong>，最好不要对以前的日志进行改动，这点我们可能通常会忽略，如果没有必要，建议不要对日志进行大的变动，防止自动化工具和其他分析日志的同学不知情。</li></ol><p>什么？你说你们团队还没有日志系统？</p><p>那么第一件事，就是要有一个完善的离线日志回捞系统或在线日志系统。</p><h2 id="3-打破边界有助于开阔视野，但是是否深入需要慎重决定"><a href="#3-打破边界有助于开阔视野，但是是否深入需要慎重决定" class="headerlink" title="3. 打破边界有助于开阔视野，但是是否深入需要慎重决定"></a>3. 打破边界有助于开阔视野，但是是否深入需要慎重决定</h2><p>虽然有的时候，员工打破边界对于公司来书并不是一个好事情，但大多数情况来说，对个人还是会有所帮助的。</p><blockquote><p>为什么说不是一个好事情呢，比如一个客户端的同学，去做 c++ 了，这个时候应该鼓励还是反对呢。实际上这个时候，他除了仅存的业务熟悉度和一些通用的编程能力，c++ 的能力也许就只有应届生的水平，如果从新招聘可能连初试都过不了。公司就必须要承担因为他的编程能力不熟练带来的效率损失，甚至因为更容易引发问题造成更大的损失。</p></blockquote><p>为什么说，对于个人来说是一个好事情呢，这个主要体现在以下几个方面：</p><ul><li>在公司中大多数情况下都是多个语言的开发者相互配合的，而当你同时参与了你上游或者下游的工作，你会发现沟通会更加顺畅了，甚至自己也拥有了简单的处理需求和问题的能力，底气会高很多。</li><li>在你学习多个语言的过程中你会发现一些精华的部分，比如通用的框架设计方法、模块组织方法等各个语言都是通用的，甚至有些代码你直接翻译过来就可以直接用了，这也可以让你更深刻地了解到哪些是编程的精髓。</li></ul><p>当然，有的时候如果你跨界参与的太多，例如本身是一个资深的前端开发者，当你跨界参与了 c++ 开发，你会发现短时间内你的前端水平是在下降的，而 c++ 水平也没有达到独立承担工作的程度，这短时间内你的市场价值其实是有所下降的，这也是你需要慎重考虑到底要参与多少的原因之一。</p><h2 id="4-复杂系统的初始架构设计，可以作为一个最后兜底"><a href="#4-复杂系统的初始架构设计，可以作为一个最后兜底" class="headerlink" title="4. 复杂系统的初始架构设计，可以作为一个最后兜底"></a>4. 复杂系统的初始架构设计，可以作为一个最后兜底</h2><p>实际上，复杂的系统大多一开始都不复杂，但是如何正确地预判系统的走向，设计出可以沿用很久的基础骨架、约束性强却扩展型足够的组件系统（即使后来来的人水平差也不至于写出太难维护的代码），以及和外界其他系统进行灵活的配合，是对水平有一定的考验的。</p><p>这里我以某视频会议 App 举例，其最开始只有视频+音频的简单能力，在此基础上，团队负责人设计并编写了基于 Typescript 的核心状态机、按照 minor repo 划分了主要模块，设计了 Store 状态存储，设计了一套 API 注入方式可以注入系统外的 API 等等。</p><p>这套架构沿用了三年，核心代码基本没有发生变化，功能上却新增了共享屏幕、共享网页、聊天/表情、标注/白板、远程控制、字幕/录制/翻译、日程会议、面试等若干重要的模块。</p><p>虽然实际上，随着后面的同学的增多，以及最初核心开发者的离职，开发人员已经几乎换了一批，但是这套代码和架构基本上没发生太多变化，也一直支撑着若干项目。</p><p>（p.s. 据说最开始参与设计的同学吐槽后面的维护有点渐渐跑题，但是整体还是可用性比较高的）。</p><p>如果没有一定水平，想必业务框架早就随着业务的变更重构过多次了，肯定会带来巨大的人力浪费。</p><h2 id="5-持续练习，持续关注行业动态"><a href="#5-持续练习，持续关注行业动态" class="headerlink" title="5. 持续练习，持续关注行业动态"></a>5. 持续练习，持续关注行业动态</h2><p>最后一点，持续学习，大概是程序员的宿命吧。</p><p>这里其实不用多说了，但是想提一点，其实有的时候如果你发现主动的持续学习会比较难的情况下，可以选择一种半被动的方式。</p><p>比如，每周给自己定日程参与 leetcode 周赛，你把它当作自己工作的无可推脱的一部分，这样持续几次，你就会慢慢习惯这个过程。</p><hr><p>以上共勉。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/395177123&quot;&gt;知乎版本&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目所述，就是我最近很久一段时间都在用来思考的问题。&lt;/p&gt;
&lt;p&gt;先说下个人的背景，目前已经毕业三年，第一年主要做前端开发，大约在两年前，我的</summary>
      
    
    
    
    
    <category term="前端综合" scheme="http://niexiaotao.cn/tags/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Deno 是如何运行 TypeScript 的？</title>
    <link href="http://niexiaotao.cn/2021/01/31/Deno%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%20TypeScript%20%E7%9A%84/"/>
    <id>http://niexiaotao.cn/2021/01/31/Deno%20%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%20TypeScript%20%E7%9A%84/</id>
    <published>2021-01-31T10:07:20.000Z</published>
    <updated>2022-04-13T07:07:01.185Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Deno，一个 JavaScript/TypeScript 运行时。本文并不会从 JavaScript 的角度来去介绍如何使用 Deno，而是试图从框架实现的角度，来整体对 Deno 项目本身的开发实现进行解读，并且通过分析其运行 TypeScript 的原理，来对其进行一个入门的剖析。</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/348379605">原文链接已经转移至这里</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Deno，一个 JavaScript/TypeScript 运行时。本文并不会从 JavaScript 的角度来去介绍如何使用 Deno，而是试图从框架实现的角度，来整体对 Deno 项目本身的开发实现进行解读，并且通过分析其运行 TypeScri</summary>
      
    
    
    
    
    <category term="前端框架" scheme="http://niexiaotao.cn/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用 Rust WebAssembly 0拷贝进行计算加速</title>
    <link href="http://niexiaotao.cn/2020/06/26/%E4%BD%BF%E7%94%A8RustWebAssembly0%E6%8B%B7%E8%B4%9D%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F/"/>
    <id>http://niexiaotao.cn/2020/06/26/%E4%BD%BF%E7%94%A8RustWebAssembly0%E6%8B%B7%E8%B4%9D%E8%BF%9B%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%8A%A0%E9%80%9F/</id>
    <published>2020-06-26T06:47:03.000Z</published>
    <updated>2022-04-13T07:07:01.192Z</updated>
    
    <content type="html"><![CDATA[<p>demo: <a href="https://github.com/aircloud/rust-wasm-demo">https://github.com/aircloud/rust-wasm-demo</a>  </p><p>其他资料：<a href="https://zhuanlan.zhihu.com/p/104299612">入门 Rust 开发 WebAssembly</a></p><p>一般来说，使用 WebAssembly 能够在一定程度上提高性能，不过有的时候我们也许会发现，使用 WebAssembly 之后，有的时候我们不仅发现性能没有提升，反而下降了许多甚至数倍，实际上这是因为，使用 WebAssembly 需要非常谨慎，有很多细节都会大幅度影响性能，比如：</p><ul><li>我们编译采用的是 debug 还是 release 方式。</li><li>最后编译的结果是否采用了不同级别的优化，如果使用了 <code>opt-level = &#39;s&#39;</code> 那么通常速度也会下降很多。</li><li>是否在 JS 和 rust 之间存在大量的数据拷贝，因为很多代码是工具链生成的，也许有的时候我们会忽视这一点。</li></ul><p>本文针对以上等一些问题特别是第三点，给出一个 wasm 优化的参考方案，并给出示例代码。</p><h3 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h3><p>我们在优化数据拷贝之前，对于编译我们可以做一些前置的简单的工作。</p><ul><li>检查 Cargo.toml 脚本中 <code>[profile.release]</code> 中的 <code>opt-level</code> 选项，确认我们所使用的值：</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">This flag controls the optimization <span class="keyword">level</span>.</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: <span class="keyword">no</span> optimizations, <span class="keyword">also</span> turns <span class="keyword">on</span> cfg(debug_assertions) (the <span class="keyword">default</span>).</span><br><span class="line"><span class="number">1</span>: basic optimizations.</span><br><span class="line"><span class="number">2</span>: <span class="keyword">some</span> optimizations.</span><br><span class="line"><span class="number">3</span>: <span class="keyword">all</span> optimizations.</span><br><span class="line">s: optimize <span class="keyword">for</span> binary size.</span><br><span class="line">z: optimize <span class="keyword">for</span> binary size, but <span class="keyword">also</span> turn <span class="keyword">off</span> <span class="keyword">loop</span> vectorization.</span><br><span class="line">Note: The -O flag <span class="keyword">is</span> an <span class="keyword">alias</span> <span class="keyword">for</span> -C opt-<span class="keyword">level</span>=<span class="number">2.</span></span><br><span class="line"></span><br><span class="line">The <span class="keyword">default</span> <span class="keyword">is</span> <span class="number">0.</span></span><br></pre></td></tr></table></figure><p>如果我们使用了 ‘s’ 或者 ‘z’，那么通常会牺牲一部分性能（对于 demo 而言，使用 ‘z’， wasm 的性能也只有 js 的 20%），因为其主要是对体积进行一定的优化，所以如果优化前的体积我们可以接受的话，通常不需要这样的优化。</p><p>在以上的前提下，我们使用 <code>--release</code> 的方式编译，通常就可以了。</p><h3 id="减少拷贝"><a href="#减少拷贝" class="headerlink" title="减少拷贝"></a>减少拷贝</h3><p>在这之前，我们需要有一个认知：</p><p><strong>通过 rust 工具链编译的 wasm 代码，所有参数传入都是需要拷贝一次的，包括我们传入 ArrayBuffer 等 Buffer 类型的参数。</strong>这是由于 wasm 只能访问自己的线性内存，而这个拷贝，通常是我们在处理大规模计算的一个坎，有的时候虽然 wasm 计算快一点，但是拷贝的消耗还是比较大的，加之 js 有若干 v8 优化的加持，可能和 wasm 也相差不多。</p><p>所以我们要把计算移植到 wasm 中的话，首先要解决的就是大规模数据拷贝的问题。</p><p>这里的一般思路为：</p><ol><li>wasm 分配内存：调用 wasm 的方法，在 wasm 内存中分配空间，返回指针位置</li><li>js 写入数据：js 端在 wasm 的 memory arraybuffer 上，按指针位置和数据量建立 view，把数据写入</li><li>wasm 计算：调用 wasm 方法完成计算， 返回计算好的批量结果的指针位置和大小</li><li>js 读取数据：js 端在 wasm 的 memory arraybuffer上，按指针位置和数据量建立 view，把数据读出</li></ol><p>接下来，我们通过一个 demo 来完成以上几点，demo 的主要功能为：</p><ul><li>初始化一个 ImageData，内容随机。</li><li>分别使用 js 和 WebAssembly 进行高斯模糊计算，并计算二者的时间，进行对比。</li></ul><p>这里的 demo 只是辅助进行验证改方案的可行性并且给出一个示例，并不作为一个标准的 benchmark 去对比 js 和 WebAssembly 的性能，同时，也并没有 UI 展示，计算结果输出在控制台中。</p><p>最终笔者运行的结果为，js 比 WebAssembly 慢 30% 左右。</p><h4 id="1-wasm-分配内存"><a href="#1-wasm-分配内存" class="headerlink" title="1. wasm 分配内存"></a>1. wasm 分配内存</h4><p>这部分的通用做法，即我们在 wasm 的 rust 中分配一个数组（Vec），然后把其指针传递给 js：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rust：</span></span><br><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new_buffer</span></span>(key: <span class="built_in">String</span>, len: <span class="built_in">usize</span>) -&gt; *<span class="keyword">const</span> <span class="built_in">u8</span> &#123;</span><br><span class="line">  <span class="comment">// GlobalBufferStorage 是一个 lazy_static</span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> global_buffer_storage = GlobalBufferStorage.lock().unwrap();</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> buffer = <span class="built_in">vec!</span>[<span class="number">255</span>; len];</span><br><span class="line">  <span class="keyword">let</span> ptr = buffer.as_ptr();</span><br><span class="line">  global_buffer_storage.buffer_map.insert(key, buffer);</span><br><span class="line">  ptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了后续方便寻找到这段数据，我们可以使用一个 key 将这个 Vec 联系起来，并且在 Rust 中放入全局（可以使用 lazy_static!，因为这种类型的数据没有办法直接定义在全局），之后通过 key 来查找数据。</p><p>在 js 中，我们就可以建立各种 TypedArray 对其进行操作：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const ptr = this.wasm!.<span class="keyword">new</span><span class="constructor">_buffer(<span class="params">key</span>, <span class="params">len</span>)</span>;</span><br><span class="line">const u8Arr = <span class="keyword">new</span> <span class="constructor">Uint8ClampedArray(<span class="params">this</span>.<span class="params">wasm</span>!.<span class="params">get_wasm_buffer</span>()</span>, ptr, len);</span><br></pre></td></tr></table></figure><p><strong>这个时候，我们在 js 或 rust 任何一侧改了这个数据之后，都可以在另外一侧访问到。</strong></p><p>实际上，在 js 侧的比如 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ImageData/ImageData">ImageData</a> 等一些对象中，也支持我们传递一个 TypedArray 进行初始化，这让我们在比如 canvas 等应用场景下，使用 wasm 分配的内存更为方便。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const imageData = <span class="keyword">new</span> <span class="constructor">ImageData(<span class="params">u8Arr</span>, <span class="params">width</span>, <span class="params">height</span>)</span>;</span><br></pre></td></tr></table></figure><h4 id="2-js-写入数据"><a href="#2-js-写入数据" class="headerlink" title="2. js 写入数据"></a>2. js 写入数据</h4><p>如果我们需要在 js 侧写入数据，实际上这个时候我们得到的 TypedArray 已经和直接使用 js new 的 TypedArray 在使用上没有差别，可以正常按照数组的方式进行数据写入。</p><p>不过，这里需要注意的是，js 写入通过 wasm 分配内存建立的 TypedArray，有些场景下在一定程度上速度要慢于直接使用 js new 的 TypedArray（不过在笔者的测试数据中，wasm 分配的方式反而是更快的），所以如果我们是一个高频的数据写入的场景，比如帧数据等，这个时候最好进行一次对比测试。</p><h4 id="3-wasm-计算"><a href="#3-wasm-计算" class="headerlink" title="3. wasm 计算"></a>3. wasm 计算</h4><p>当我们真正需要进行计算的时候，我们可以调用 wasm 的计算函数，并且传入上文中定义的 key，这样 wasm 的 rust 函数可以直接找到这段数据，这里我们的 demo 为一段计算卷积的函数：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">convolution</span></span>(key: <span class="built_in">String</span>, width: <span class="built_in">usize</span>, height: <span class="built_in">usize</span>, kernel: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> global_buffer_storage = GlobalBufferStorage.lock().unwrap();</span><br><span class="line">  <span class="keyword">let</span> kernel_length = kernel.iter().sum::&lt;<span class="built_in">i32</span>&gt;() <span class="keyword">as</span> <span class="built_in">i32</span>;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(buffer) = global_buffer_storage.buffer_map.get_mut(&amp;key) &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..width-<span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..height-<span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> newR: <span class="built_in">i32</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> newG: <span class="built_in">i32</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> newB: <span class="built_in">i32</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123; <span class="comment">// 取前后左右共9个格子</span></span><br><span class="line">          <span class="keyword">for</span> y <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span> &#123;</span><br><span class="line">            newR += buffer[width * (j + y - <span class="number">1</span>) * <span class="number">4</span> + (i + x - <span class="number">1</span>) * <span class="number">4</span> + <span class="number">0</span>] <span class="keyword">as</span> <span class="built_in">i32</span> * kernel[y * <span class="number">3</span> + x] / kernel_length;</span><br><span class="line">            newG += buffer[width * (j + y - <span class="number">1</span>) * <span class="number">4</span> + (i + x - <span class="number">1</span>) * <span class="number">4</span> + <span class="number">1</span>] <span class="keyword">as</span> <span class="built_in">i32</span> * kernel[y * <span class="number">3</span> + x] / kernel_length;</span><br><span class="line">            newB += buffer[width * (j + y - <span class="number">1</span>) * <span class="number">4</span> + (i + x - <span class="number">1</span>) * <span class="number">4</span> + <span class="number">2</span>] <span class="keyword">as</span> <span class="built_in">i32</span> * kernel[y * <span class="number">3</span> + x] / kernel_length;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[width * j * <span class="number">4</span> + i * <span class="number">4</span> + <span class="number">0</span>] = newR <span class="keyword">as</span> <span class="built_in">u8</span>;</span><br><span class="line">        buffer[width * j * <span class="number">4</span> + i * <span class="number">4</span> + <span class="number">1</span>] = newG <span class="keyword">as</span> <span class="built_in">u8</span>;</span><br><span class="line">        buffer[width * j * <span class="number">4</span> + i * <span class="number">4</span> + <span class="number">2</span>] = newB <span class="keyword">as</span> <span class="built_in">u8</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这段函数对应操作的内存数据实际上已经在 wasm 和 js 之间共享了，所以也是不需要返回值的，等计算完成后 js 直接去读之前建立的 TypedArray，甚至直接使用通过 TypedArray 创建的 ImageData，进行绘制上屏等后续操作。</p><h4 id="4-js-读取数据"><a href="#4-js-读取数据" class="headerlink" title="4. js 读取数据"></a>4. js 读取数据</h4><p>在 demo 中，我们可以直接通过 <code>CanvasRenderingContext2D.putImageData()</code> 传入之前获取的 imageData，绘制上屏。</p><h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3><p>实际上，我们如果目的是加速 js 计算，不仅仅有 WebAssembly 这一个方案可以选择，如果我们的环境中拥有可以访问 Node 的能力或者可以访问原生模块的能力（比如，我们的应用运行在 electron 环境，或者是一些移动客户端），也可以采用比如 addon 的方式来运行我们的计算部分，相比于 wasm，这部分的优缺点在于：</p><p>优点：</p><ul><li>通常可以更好的控制优化，甚至做到汇编级别的优化定制，性能提升空间更高（同样也可能会面临数据拷贝的问题，也需要一定方式减少拷贝）。</li><li>在重 addon 的环境下（例如，其他大量功能也依赖 addon），可以更好的处理函数调用关系、依赖库使用等，一定程度上减少体积和增加开发的便捷性，而 wasm 会被编译成一个独立的二进制文件，处于沙盒环境中，无法直接调用其他的动态库。</li></ul><p>缺点：</p><ul><li>无法做到像 wasm 一样跨平台，并且可以同时运行在网页、桌面环境、移动端等任何 Webview 存在的环境中。</li></ul><p>不过总之，如果使用得当，二者的性能都是可以优于原生的 js，都可以作为优化方案考虑。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;demo: &lt;a href=&quot;https://github.com/aircloud/rust-wasm-demo&quot;&gt;https://github.com/aircloud/rust-wasm-demo&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;其他资料：&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="Rust" scheme="http://niexiaotao.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>使用 OpenCV 实现简单的人脸识别程序</title>
    <link href="http://niexiaotao.cn/2019/09/10/%E4%BD%BF%E7%94%A8OpenCV%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%A8%8B%E5%BA%8F/"/>
    <id>http://niexiaotao.cn/2019/09/10/%E4%BD%BF%E7%94%A8OpenCV%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%A8%8B%E5%BA%8F/</id>
    <published>2019-09-10T07:34:13.000Z</published>
    <updated>2022-04-13T07:07:01.192Z</updated>
    
    <content type="html"><![CDATA[<p>本问就 Mac 系统安装 OpenCV 以及实现一个简单的人脸识别程序进行记录。</p><h3 id="安装-OpenCV"><a href="#安装-OpenCV" class="headerlink" title="安装 OpenCV"></a>安装 OpenCV</h3><p>实际上，OpenCV 的安装方式比较多，这里为了避免一些第三方安装的问题，我们采用源代码方式安装。</p><p>安全前请确保本机已经安装了 CMake 和 Xcode。</p><p>我们去<a href="https://opencv.org/releases/"> OpenCV 的网站</a> 下载源代码，选择 Release -&gt; SourceCode，可以选择最新的 4.11 版本。</p><p>这里以 4.1.1 版本为例，下载后我们解压到 <code>opencv-4.1.1</code>，然后进入到该目录，新建一个 release 目录用于存放我们构建好的内容，并进入到该目录：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir release</span><br><span class="line">cd release/</span><br></pre></td></tr></table></figure><p>然后我们依次执行以下命令安装：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -G “Unix Makefiles” .. </span><br><span class="line"><span class="built_in">make</span></span><br><span class="line"><span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><p>全部命令执行成功后，实际上就安装完成了，我们可以从最后的输出中看到，相关内容已经被安装到了 <code>/usr/local/include</code>、<code>/usr/local/lib</code> 等文件夹下。</p><h3 id="使用-Xcode-编写人脸识别程序"><a href="#使用-Xcode-编写人脸识别程序" class="headerlink" title="使用 Xcode 编写人脸识别程序"></a>使用 Xcode 编写人脸识别程序</h3><p>我们可以使用 Xcode 建立一个命令行程序，这里我们还需要处理两个问题：</p><ul><li>OpenCV 的引入</li><li>摄像头权限的获取</li></ul><h4 id="OpenCV-的引入"><a href="#OpenCV-的引入" class="headerlink" title="OpenCV 的引入"></a>OpenCV 的引入</h4><p>对于第一点，我们在 <strong>Build Setting</strong> 的 <strong>Search Paths</strong> 中增加 Header 和 Library 的路径：</p><p><img src="/img/cv1.jpg" alt="路径"></p><p>然后我们需要在 <strong>Build Phases</strong> 的 <strong>Link Binary With Libraries</strong> 中增加动态链接库。</p><p>我们可以点击左下角加号，选择 <code>Add Others</code> 然后进入 <code>/usr/local/lib</code> 把 OpenCV 相关的库均包含进来即可。</p><blockquote><p>实际上我们可以部分引入，但是由于我们是初步上手，全部引入也可以。</p></blockquote><h4 id="摄像头权限的获取"><a href="#摄像头权限的获取" class="headerlink" title="摄像头权限的获取"></a>摄像头权限的获取</h4><p>这里如果我们直接运行我们的程序，在 macOS 最新的系统中是无法运行通过的，这里涉及到摄像头权限问题。</p><p>一般来说，对于 macOS，我们需要在运行程序的目录下声明 <code>info.plist</code>, 这样程序在运行的时候系统会自动有申请权限的弹窗，对于我们测试场景下而言，我们可以这样做：</p><ul><li>进入我们 Product 存放的目录（注意不是项目代码目录，可以在 Products 条目右单击 <code>Show in Finder</code>）</li><li>复制一个 info.plist（这里我们可以随便找一个本地安装的应用程序的 info.plist，一般右单击显示包内容即可看到）</li><li>在 info.plist 中增加 <code>NSCameraUsageDescription</code>，value 即提示语，可以写比如 <code>摄像头权限的获取</code>。</li></ul><h4 id="书写并运行程序"><a href="#书写并运行程序" class="headerlink" title="书写并运行程序"></a>书写并运行程序</h4><p>做完上述准备工作后，我们可以写我们的人脸识别程序了，这里给出一个成功运行的代码示例（参考了网上的一些例子）：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">capture</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否退出摄像头抓取线程</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> g_quit = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">capture</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">capture</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开摄像头</span></span><br><span class="line">    <span class="function">cv::VideoCapture <span class="title">cap</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果打开失败，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (!cap.<span class="built_in">isOpened</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Open Capture Failed&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 人脸识别分类器</span></span><br><span class="line">    <span class="function">cv::CascadeClassifier <span class="title">faceCascadeClassifier</span><span class="params">(<span class="string">&quot;/usr/local/share/opencv4/haarcascades/haarcascade_frontalface_alt2.xml&quot;</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取 Frame ，直到退出系统</span></span><br><span class="line">    <span class="keyword">while</span> (!g_quit)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Mat frame;</span><br><span class="line">        <span class="keyword">if</span> (!cap.<span class="built_in">read</span>(frame))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取失败，返回错误</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进行人脸识别</span></span><br><span class="line">        std::vector&lt;cv::Rect&gt; faces;</span><br><span class="line">        faceCascadeClassifier.<span class="built_in">detectMultiScale</span>(frame, faces);</span><br><span class="line">        <span class="comment">// 将人脸识别结果绘制到图片上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; face : faces)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Find Face&quot;</span>&lt;&lt;endl;</span><br><span class="line">            cv::<span class="built_in">rectangle</span>(frame,</span><br><span class="line">                          cv::<span class="built_in">Point</span>(face.x, face.y),</span><br><span class="line">                          cv::<span class="built_in">Point</span>(face.x + face.width, face.y + face.height),</span><br><span class="line">                          <span class="built_in">CV_RGB</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                          <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">imshow</span>(<span class="string">&quot;Display Image&quot;</span>, frame);</span><br><span class="line">        <span class="built_in">waitKey</span>(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里值得注意的是，我们这里使用的人脸识别分类器是 OpenCV 安装后自带的，你本机的目录可能并不是这一个（这个路径实际上安装好 OpenCV 之后会打印在控制台）。</p><p>正常情况下，以上程序可以直接编译执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本问就 Mac 系统安装 OpenCV 以及实现一个简单的人脸识别程序进行记录。&lt;/p&gt;
&lt;h3 id=&quot;安装-OpenCV&quot;&gt;&lt;a href=&quot;#安装-OpenCV&quot; class=&quot;headerlink&quot; title=&quot;安装 OpenCV&quot;&gt;&lt;/a&gt;安装 OpenCV&lt;/</summary>
      
    
    
    
    
    <category term="OpenCV" scheme="http://niexiaotao.cn/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>Rust初探:实现二叉树的增删与遍历</title>
    <link href="http://niexiaotao.cn/2019/09/07/Rust%E5%88%9D%E6%8E%A2-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
    <id>http://niexiaotao.cn/2019/09/07/Rust%E5%88%9D%E6%8E%A2-%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%A2%9E%E5%88%A0%E4%B8%8E%E9%81%8D%E5%8E%86/</id>
    <published>2019-09-07T15:57:28.000Z</published>
    <updated>2022-04-13T07:07:01.187Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Rust-简介"><a href="#Rust-简介" class="headerlink" title="Rust 简介"></a>Rust 简介</h3><p>实际上自己接触 Rust 的时间还是很有限的，这里也不会对 Rust 进行长篇大论地介绍，简单来说，Rust 是一个性能和 c++ 相近的系统级编程语言，同时，由于其所有权与变量生命周期等机制的设计，使其相对于 c++ 来说拥有内存安全的优势，几乎不会出现诸如悬垂指针、数组越界、段错误等问题，在微软、百度、字节跳动等公司均有所使用。</p><p>关于 Rust 的特性以及未来，知乎<a href="https://www.zhihu.com/question/30407715">这个问题中的一些高赞回答以及相关的评论</a>，非常值得一看。</p><p>本文会以二叉树这样一个具体的例子出发，来对 Rust 的一部分知识内容进行学习。</p><h3 id="实现二叉树数据结构"><a href="#实现二叉树数据结构" class="headerlink" title="实现二叉树数据结构"></a>实现二叉树数据结构</h3><h4 id="定义结构"><a href="#定义结构" class="headerlink" title="定义结构"></a>定义结构</h4><p>之前在 Javascript 等语言中，我们只要对对象有所了解，实现一个二叉树的数据结构是非常简单的事情，而在 Rust 中，可能对于新手来说仅仅是实现基本的数据结构就是一个比较脑壳疼的事情。</p><p>我们一般会写出类似这样的代码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="class">Tree </span>&#123;</span><br><span class="line"><span class="symbol">    value:</span> i32,</span><br><span class="line"><span class="symbol">    left:</span> Tree, <span class="comment">// 直接使用 Tree 是不行的</span></span><br><span class="line"><span class="symbol">    right:</span> Tree  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自然不会通过 Rust 的编译检查，会报错例如：<code>recursive type has infinite size</code>，不过其同时给我们提供了解决方案，这里我们使用 <code>Box&lt;T&gt;</code> 指针。</p><p>另外，考虑到二叉树的左右子树可能为空，所以这里我们还需要增加一个 <code>Option</code>。</p><p>最终我们的二叉树数据结构定义如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line">struct <span class="class">Tree </span>&#123;</span><br><span class="line"><span class="symbol">    value:</span> i32,</span><br><span class="line"><span class="symbol">    left:</span> Option<span class="params">&lt;Box&lt;Tree&gt;</span>&gt;,</span><br><span class="line"><span class="symbol">    right:</span> Option<span class="params">&lt;Box&lt;Tree&gt;</span>&gt;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现基本的方法"><a href="#实现基本的方法" class="headerlink" title="实现基本的方法"></a>实现基本的方法</h4><p>这里我们实现一些二叉树的基本的方法，作为上述结构体的方法，我们将实现以下方法：</p><ul><li>获取二叉树节点的值（其实也可以没有这个方法）。</li><li>修改二叉树节点的值。</li><li>设置子树。</li><li>删除子树。</li></ul><p>这里除了第一个，其余我们都需要传递 <code>self</code> 的可变引用，我们的实现如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Tree &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_val</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_val</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, val: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">insert</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, dir: &amp;<span class="built_in">String</span>, val: Tree) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(dir == <span class="string">&quot;left&quot;</span> || dir == <span class="string">&quot;right&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> dir.as_ref() &#123;</span><br><span class="line">            <span class="string">&quot;left&quot;</span> =&gt; <span class="keyword">self</span>.left = <span class="literal">Some</span>(<span class="built_in">Box</span>::new(val)),</span><br><span class="line">            <span class="string">&quot;right&quot;</span> =&gt; <span class="keyword">self</span>.right = <span class="literal">Some</span>(<span class="built_in">Box</span>::new(val)),</span><br><span class="line">            _ =&gt; &#123; </span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class="line">                process::exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, dir: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(dir == <span class="string">&quot;left&quot;</span> || dir == <span class="string">&quot;right&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> dir.as_ref() &#123;</span><br><span class="line">                <span class="string">&quot;left&quot;</span> =&gt; <span class="keyword">self</span>.left = <span class="literal">None</span>,</span><br><span class="line">                <span class="string">&quot;right&quot;</span> =&gt; <span class="keyword">self</span>.right = <span class="literal">None</span>,</span><br><span class="line">                 _ =&gt; &#123; </span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class="line">                    process::exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><p>这里遍历二叉树我们作为一个单独的方法，而不是属性方法来实现，这样会更符合我们平时的业务场景，这里其实问题比较多的，我们先简易实现一个版本：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fn</span> <span class="selector-tag">traverse</span>(<span class="attribute">tree</span>: Tree) &#123;</span><br><span class="line">    <span class="selector-tag">println</span>!(<span class="string">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class="line">    <span class="selector-tag">if</span> <span class="selector-tag">tree</span><span class="selector-class">.left</span><span class="selector-class">.is_some</span>() &#123;</span><br><span class="line">        <span class="selector-tag">traverse</span>(*tree.left.unwrap()); <span class="comment">// 手动解引用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">if</span> <span class="selector-tag">tree</span><span class="selector-class">.right</span><span class="selector-class">.is_some</span>() &#123;</span><br><span class="line">        <span class="selector-tag">traverse</span>(*tree.right.unwrap()); <span class="comment">// 手动解引用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们测试一下这个版本，发现的确能够正常遍历的，但是实际上这有一个致命的问题：</p><p>这里采用的是所有权的移动，而不是不可变借用，这会导致我们的函数执行完后原来变量的所有权已经被移动了，换一种说法则是会消耗掉这个变量，这显然不是我们预期的。</p><p>虽然我们也可以在函数中返回 tree 的方式来最后再次移动所有权，但这样非常不便于实现，经过重构，我们采用了如下的方式实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fn traverse(tree: &amp;Tree) &#123;</span><br><span class="line">    println!(<span class="string">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class="line">    <span class="keyword">match</span> tree.left &#123;</span><br><span class="line">        <span class="constructor">Some(<span class="params">ref</span> <span class="params">x</span>)</span> =&gt; traverse(x),</span><br><span class="line">       <span class="function"> <span class="params">_</span> =&gt;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> tree.right &#123;</span><br><span class="line">        <span class="constructor">Some(<span class="params">ref</span> <span class="params">x</span>)</span> =&gt; traverse(x),</span><br><span class="line">       <span class="function"> <span class="params">_</span> =&gt;</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>另外一个注意点则是由于 <code>unwrap()</code> 本身是一个消耗性操作，我们这里不能使用 <code>unwrap</code>，参考<a href="https://stackoverflow.com/questions/22282117/how-do-i-borrow-a-reference-to-what-is-inside-an-optiont">stackOverflow的提问1</a>、<a href="https://stackoverflow.com/questions/32338659/cannot-move-out-of-borrowed-content-when-unwrapping">stackOverflow的提问2</a>。</p></blockquote><p>我们最终的完整代码如下：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">use::std::process;</span><br><span class="line"><span class="keyword">use</span> std::borrow::Borrow;</span><br><span class="line"><span class="meta">#[derive(Debug, Default)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tree</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    left: <span class="built_in">Option</span>&lt;<span class="built_in">Box</span>&lt;Tree&gt;&gt;,</span><br><span class="line">    right: <span class="built_in">Option</span>&lt;<span class="built_in">Box</span>&lt;Tree&gt;&gt;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Tree &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">get_val</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">set_val</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, val: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = val;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">insert</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, dir: &amp;<span class="built_in">String</span>, val: Tree) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(dir == <span class="string">&quot;left&quot;</span> || dir == <span class="string">&quot;right&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> dir.as_ref() &#123;</span><br><span class="line">            <span class="string">&quot;left&quot;</span> =&gt; <span class="keyword">self</span>.left = <span class="literal">Some</span>(<span class="built_in">Box</span>::new(val)),</span><br><span class="line">            <span class="string">&quot;right&quot;</span> =&gt; <span class="keyword">self</span>.right = <span class="literal">Some</span>(<span class="built_in">Box</span>::new(val)),</span><br><span class="line">            _ =&gt; &#123; </span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class="line">                process::exit(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">delete</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, dir: &amp;<span class="built_in">String</span>) &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(dir == <span class="string">&quot;left&quot;</span> || dir == <span class="string">&quot;right&quot;</span>);</span><br><span class="line">        <span class="keyword">match</span> dir.as_ref() &#123;</span><br><span class="line">                <span class="string">&quot;left&quot;</span> =&gt; <span class="keyword">self</span>.left = <span class="literal">None</span>,</span><br><span class="line">                <span class="string">&quot;right&quot;</span> =&gt; <span class="keyword">self</span>.right = <span class="literal">None</span>,</span><br><span class="line">                 _ =&gt; &#123; </span><br><span class="line">                    <span class="built_in">println!</span>(<span class="string">&quot;Insert Error: only left and right supported&quot;</span>);</span><br><span class="line">                    process::exit(<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原始的非消耗性遍历:</span></span><br><span class="line"><span class="comment">// fn traverse(tree: &amp;Tree) &#123;</span></span><br><span class="line"><span class="comment">//     println!(&quot;Node Value: &#123;:?&#125;&quot;, tree.value);</span></span><br><span class="line"><span class="comment">//     if tree.left.is_some() &#123;</span></span><br><span class="line"><span class="comment">//         // cannot move out of borrowed content</span></span><br><span class="line"><span class="comment">//         // 首先 unwrap 是一个消耗性操作</span></span><br><span class="line"><span class="comment">//         // 这是由于 unwrap 函数造成?  as_ref 也不行</span></span><br><span class="line"><span class="comment">//         traverse((tree.left.as_ref().map(|x| **x).unwrap()).borrow());</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     // if tree.right.is_some() &#123;</span></span><br><span class="line"><span class="comment">//     //     // cannot move out of borrowed content</span></span><br><span class="line"><span class="comment">//     //     traverse(tree.right.unwrap().borrow());</span></span><br><span class="line"><span class="comment">//     // &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非消耗性遍历</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">traverse</span></span>(tree: &amp;Tree) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Node Value: &#123;:?&#125;&quot;</span>, tree.value);</span><br><span class="line">    <span class="keyword">match</span> tree.left &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> x) =&gt; traverse(x),</span><br><span class="line">        _ =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">match</span> tree.right &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="keyword">ref</span> x) =&gt; traverse(x),</span><br><span class="line">        _ =&gt; &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消耗性遍历：</span></span><br><span class="line"><span class="comment">// fn traverse(tree: Tree) &#123;</span></span><br><span class="line"><span class="comment">//     println!(&quot;Node Value: &#123;:?&#125;&quot;, tree.value);</span></span><br><span class="line"><span class="comment">//     if tree.left.is_some() &#123;</span></span><br><span class="line"><span class="comment">//         traverse(*tree.left.unwrap()); // 手动解引用</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     if tree.right.is_some() &#123;</span></span><br><span class="line"><span class="comment">//         traverse(*tree.right.unwrap()); // 手动解引用</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;begin rust tree test:&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> tree = Tree &#123; value : <span class="number">12</span>, ..<span class="built_in">Default</span>::default() &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> left = Tree &#123; value : <span class="number">121</span>, ..<span class="built_in">Default</span>::default() &#125;;</span><br><span class="line">    tree.insert(&amp;<span class="built_in">String</span>::from(<span class="string">&quot;left&quot;</span>), left);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> right = Tree &#123; value : <span class="number">122</span>, ..<span class="built_in">Default</span>::default() &#125;;</span><br><span class="line">    tree.insert(&amp;<span class="built_in">String</span>::from(<span class="string">&quot;right&quot;</span>), right);</span><br><span class="line">    <span class="comment">// tree.delete(&amp;String::from(&quot;right&quot;));</span></span><br><span class="line">    <span class="comment">// println!(&quot;Tree val: &#123;:?&#125;&quot;, left.get_val()); 不能这样写，所有权已经被移动</span></span><br><span class="line">    traverse(&amp;tree);</span><br><span class="line">    <span class="comment">// traverse(tree);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Rust-简介&quot;&gt;&lt;a href=&quot;#Rust-简介&quot; class=&quot;headerlink&quot; title=&quot;Rust 简介&quot;&gt;&lt;/a&gt;Rust 简介&lt;/h3&gt;&lt;p&gt;实际上自己接触 Rust 的时间还是很有限的，这里也不会对 Rust 进行长篇大论地介绍，简单来说，</summary>
      
    
    
    
    
    <category term="Rust" scheme="http://niexiaotao.cn/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>深入Vue源代码解决时序问题一</title>
    <link href="http://niexiaotao.cn/2019/07/06/%E6%B7%B1%E5%85%A5Vue%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%80/"/>
    <id>http://niexiaotao.cn/2019/07/06/%E6%B7%B1%E5%85%A5Vue%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E5%86%B3%E6%97%B6%E5%BA%8F%E9%97%AE%E9%A2%98%E4%B8%80/</id>
    <published>2019-07-06T07:21:51.000Z</published>
    <updated>2022-04-13T07:07:01.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>viola 是一个支持 Vue 的动态化框架，其 Vue 版本在 Vue 官方版本 2.5.7 上进行了少量改写，本文针对其进行具体分析。</p></blockquote><p>最初，有使用者报告一个错误：在 iOS 系统，退出页面的时候，框架报错：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">TypeError:</span> undefined <span class="built_in">is</span> <span class="built_in">not</span> an <span class="type">object</span>(evaluating <span class="comment">&#x27;e.isDestroyed&quot;</span></span><br></pre></td></tr></table></figure><p>接到这个错误之后，我首先进入 Vue 的 debug 版本，尝试获取更详细的信息：</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">TypeError:</span> undefined <span class="built_in">is</span> <span class="built_in">not</span> an <span class="type">object</span>(evaluating <span class="comment">&#x27;componentInstance.isDestroyed&quot;</span></span><br></pre></td></tr></table></figure><p>我们顺利地拿到了报错的变量名称，去 Vue 源代码中搜索，我们可以发现报错之处：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">destroy: <span class="function"><span class="keyword">function</span> <span class="title">destroy</span> (<span class="params">vnode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> componentInstance = vnode.componentInstance;</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isDestroyed) &#123; <span class="comment">// 这里报错</span></span><br><span class="line">      <span class="keyword">if</span> (!vnode.data.keepAlive) &#123;</span><br><span class="line">        componentInstance.$destroy();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deactivateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里是 <code>componentInstance</code> 为 undefined，这个实际上是 vnode 的实例，其为 undefined，说明该 vue 组件在之前的阶段就已经出错不正常了，这里并不是错误的根源所在，我们需要再次进行寻找报错原因。</p><p>于是我们查看业务代码的所有日志，又发现了这样一条报错：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Vue warn]: <span class="builtin-name">Error</span> <span class="keyword">in</span> nextTick: <span class="string">&quot;TypeError: undefined is not an object (evaluating &#x27;vm.<span class="variable">$options</span>&#x27;)&quot;</span> </span><br></pre></td></tr></table></figure><p>初始化阶段出现这样一个错误，我们怀疑 <code>vm</code> 就是上文的 <code>componentInstance</code>，于是，我们打印报错堆栈：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> 调用栈:</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    vm,</span></span></span><br><span class="line"><span class="params"><span class="function">    propsData,</span></span></span><br><span class="line"><span class="params"><span class="function">    listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">    parentVnode,</span></span></span><br><span class="line"><span class="params"><span class="function">    renderChildren</span></span></span><br><span class="line"><span class="params"><span class="function">  </span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">var</span> hasChildren = !!(</span><br><span class="line">              renderChildren ||</span><br><span class="line">              vm.$options._renderChildren || <span class="comment">// 这里报错</span></span><br><span class="line">              parentVnode.data.scopedSlots ||</span><br><span class="line">              vm.$scopedSlots !== emptyObject</span><br><span class="line">            );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prepatch</span>(<span class="params">oldVnode, vnode</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> options = vnode.componentOptions;</span><br><span class="line">      <span class="keyword">var</span> child = vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">      updateChildComponent(</span><br><span class="line">        child,</span><br><span class="line">        options.propsData,</span><br><span class="line">        options.listeners,</span><br><span class="line">        vnode,</span><br><span class="line">        options.children</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode, vnode, insertedVnodeQueue, removeOnly</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">vnode, hydrating</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm._update(vm._render(), hydrating);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAndInvoke</span>(<span class="params">cb</span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>调用栈实际上有点冗长，不过我们还是能发现两个有用的信息：</p><ul><li>初始化阶段为 <code>undefined</code> 的 <code>vm</code>，就是 <code>componentInstance</code>，也就是和 destroy 阶段的报错属于同一个原因。</li><li>根据调用栈发现，这是一个更新阶段的报错。</li></ul><p>这引发了我们的思考：更新阶段找不到 <code>componentInstance</code> 报错。</p><p>这里实际上有点阻塞了，因为一般来说，Vue 的源代码经过测试，应该不会出现这种问题的，那是不是我们的问题呢，我们回归到业务代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.getFeedsListFromCache();</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">getFeedsListFromCache</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        viola.requireAPI(<span class="string">&quot;cache&quot;</span>).getItem(<span class="built_in">this</span>.cacheKey_feeds, <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.processData(data.list);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">processData</span>(<span class="params">list = [], opt = &#123;&#125;</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.list.length &lt; cacehFeedsLength) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.list = [];</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对业务代码进行了抽象简化，上面是我们的最小问题 Demo，实际上我们就做了这样一件事情：</p><ul><li>在 created 执行方法，调用端的接口，再回调函数里面更新某个 data 中声明的数据。</li></ul><p>首先，我们可以梳理下对一般 vue 组件的初始化更新，vue 是如何做的：</p><ul><li>created 时实际上 vnode 已经建立完成，这个时候还没有 mount，但是数据监听已经建立了，这个时候如果改动数据，会把相关 update 函数放在一个名为 flushCallbacks 的函数队列中。</li><li>该函数队列会通过默认为 <code>Promise.then</code> 的 microtask 方式来调度，当前阶段的 mount 流程会继续，mount 结束后，会执行 flushCallbacks 队列中的更新操作。</li></ul><p>从代码层面上来讲，这几个流程应该是这样的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── call<span class="constructor">Hook(<span class="params">vm</span>, &#x27;<span class="params">created</span>&#x27;)</span>; <span class="comment">// 执行created 钩子</span></span><br><span class="line">├── proxy<span class="constructor">Setter(<span class="params">val</span>)</span>; <span class="comment">// 改变数据，调用 proxy</span></span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">Watcher</span>.</span></span>prototype.update; <span class="comment">// 调用 Watcher，将 update 操作入栈</span></span><br><span class="line">├── vm.<span class="constructor">$mount(<span class="params">vm</span>.$<span class="params">options</span>.<span class="params">el</span>)</span>; <span class="comment">// 执行 mount 流程</span></span><br><span class="line">├── call<span class="constructor">Hook(<span class="params">vm</span>, &#x27;<span class="params">beforeMount</span>&#x27;)</span>;</span><br><span class="line">├──  call<span class="constructor">Hook(<span class="params">vm</span>, &#x27;<span class="params">mounted</span>&#x27;)</span>; <span class="comment">// 依次调用 beforeMount 和 mounted</span></span><br><span class="line">└── flushCallbacks <span class="comment">// 执行 更新</span></span><br></pre></td></tr></table></figure><p>然后我们分析我们这里的流程，首先值得强调的是这个函数 <code>viola.requireAPI(&quot;cache&quot;).getItem</code>，这个函数是端注入的函数，但我们不能将其当作异步函数来对待，实际上，<strong>这是一个同步函数</strong>，（至于这个同步函数和 js 中的普通函数，是否有区别，还有待商榷，不过应该是有区别的，因为如果我们不用此函数的话，就不会出现该问题。）</p><p>接下来，我们打出详细的调用栈，根据顺序来分析实际的执行流程：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── call<span class="constructor">Hook(<span class="params">vm</span>, &#x27;<span class="params">created</span>&#x27;)</span>; <span class="comment">// 执行created 钩子</span></span><br><span class="line">├── proxy<span class="constructor">Setter(<span class="params">val</span>)</span>; <span class="comment">// 改变数据，调用 proxy</span></span><br><span class="line">├── <span class="module-access"><span class="module"><span class="identifier">Watcher</span>.</span></span>prototype.update; <span class="comment">// 调用 Watcher，将 update 操作入栈</span></span><br><span class="line">├── flushCallbacks <span class="comment">// 执行 更新</span></span><br><span class="line">├── vm.<span class="constructor">$mount(<span class="params">vm</span>.$<span class="params">options</span>.<span class="params">el</span>)</span>; <span class="comment">// 执行 mount 流程 </span></span><br><span class="line">├── call<span class="constructor">Hook(<span class="params">vm</span>, &#x27;<span class="params">beforeMount</span>&#x27;)</span>;</span><br><span class="line">└── call<span class="constructor">Hook(<span class="params">vm</span>, &#x27;<span class="params">mounted</span>&#x27;)</span>; <span class="comment">// 依次调用 beforeMount 和 mounted</span></span><br></pre></td></tr></table></figure><p>我们发现，我们的执行流程出现了很大问题：<strong>在 mount 阶段未完成的时候就执行了 flushCallbacks，先执行更新操作，这里的顺序错乱导致了后续问题</strong>。</p><p>我们可看下调用 <code>flushCallbacks</code> 的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  microTimerFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    p.then(flushCallbacks);</span><br><span class="line">    <span class="comment">// in problematic UIWebViews, Promise.then doesn&#x27;t completely break, but</span></span><br><span class="line">    <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">    <span class="comment">// microtask queue but the queue isn&#x27;t being flushed, until the browser</span></span><br><span class="line">    <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">    <span class="comment">// &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span></span><br><span class="line">    <span class="keyword">if</span> (isIOS) &#123; <span class="built_in">setTimeout</span>(noop); &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这里 <code>microTimerFunc</code> 的 <code>p.then</code>，被同步执行了，也就是说，这里的微任务优先于当前事件循环的函数执行了（此时由于 mount 流程是同步的，mount 流程的相关函数<strong>理应</strong>在该事件循环中，优先于微任务执行）。</p><p>我们找到了根源，接下来就是分析解决方案和根本原因。</p><p>由于我们的问题在于 update 流程执行太快了，所以采用一种方式放慢一点即可：</p><ul><li>将 vue 的微任务模式（默认）改成宏任务模式：<code>var useMacroTask = false; =&gt; true</code>。</li><li>在 created 阶段的加一个 <code>setTimeout(0)</code>。</li></ul><p>不过对于根本原因，实际上本次仍然没有完全分析透彻，还留有如下疑问：</p><ul><li><code>viola.requireAPI(&quot;cache&quot;).getItem</code> 这个函数到底做了什么？其对事件循环有什么影响？</li><li>在执行 <code>microTimerFunc</code> 的时候，为什么 <code>p.then</code> 优先于 <code>vm.$mount</code> 执行了？</li><li>该错误仅在 iOS 系统出现，iOS 系统是否会在某些情况将微任务的优先级变高？</li></ul><p>对于这些疑问，Vue 源代码中也做了一些评论：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> Here we have async deferring wrappers using both microtasks and (macro) tasks.</span><br><span class="line"><span class="regexp">//</span> In &lt; <span class="number">2.4</span> we used microtasks everywhere, but there are some scenarios where</span><br><span class="line"><span class="regexp">//</span> microtasks have too high a priority and fire <span class="keyword">in</span> between supposedly</span><br><span class="line"><span class="regexp">//</span> sequential events (e.g. <span class="comment">#4521, #6690) or even between bubbling of the same</span></span><br><span class="line"><span class="regexp">//</span> event (<span class="comment">#6566). However, using (macro) tasks everywhere also has subtle problems</span></span><br><span class="line"><span class="regexp">//</span> when state is changed right before repaint (e.g. <span class="comment">#6813, out-in transitions).</span></span><br><span class="line"><span class="regexp">//</span> Here we use microtask by default, but expose a way to force (macro) task when</span><br><span class="line"><span class="regexp">//</span> needed (e.g. <span class="keyword">in</span> event handlers attached by v-on).</span><br></pre></td></tr></table></figure><p>不过，这里始终都没有找到最本质的原因，也许这和 iOS JSCore 的微任务/宏任务的处理机制有关，具体原因，待下次探究。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;viola 是一个支持 Vue 的动态化框架，其 Vue 版本在 Vue 官方版本 2.5.7 上进行了少量改写，本文针对其进行具体分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最初，有使用者报告一个错误：在 iOS 系统，退出页面的时候，框架</summary>
      
    
    
    
    
    <category term="Vue" scheme="http://niexiaotao.cn/tags/Vue/"/>
    
    <category term="viola" scheme="http://niexiaotao.cn/tags/viola/"/>
    
  </entry>
  
  <entry>
    <title>web应用开发与部署——你必须掌握的内容</title>
    <link href="http://niexiaotao.cn/2019/06/16/web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%8E%E9%83%A8%E7%BD%B2%E2%80%94%E2%80%94%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://niexiaotao.cn/2019/06/16/web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E4%B8%8E%E9%83%A8%E7%BD%B2%E2%80%94%E2%80%94%E4%BD%A0%E5%BF%85%E9%A1%BB%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%86%85%E5%AE%B9/</id>
    <published>2019-06-16T14:09:20.000Z</published>
    <updated>2022-04-13T07:07:01.189Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于笔者在腾讯的项目经验，从真实场景出发分析一个中型 Web 应用从立项到上线稳定运行的平稳解决方案，力求既不太空泛以至于看完了仍然找不到落地的点，也尽量不会特别纠结于个别细节导致没有相关使用经历的同学无法感同身受，而是从宏观到方法论，分析整个流程中我们需要用到的工具、方法与规范，给大家提供一个参考。</p><p>本文适合具有一定经验的初中级前端开发者，如果有相关问题，也欢迎与我交流。</p><p>目录</p><ul><li>项目构建的搭建，关键词：<strong>webpack</strong>、<strong>react/vue cli</strong>，<strong>steamer</strong>，<strong>组件库</strong></li><li>代码的规范约束，关键词：<strong>typescript</strong>、<strong>eslint</strong>、<strong>prettier</strong></li><li>测试与测试部署，关键词：<strong>测试部署方案</strong>、<strong>docker</strong></li><li>日志查看与脚本错误的监控，关键词：<strong>sentry</strong>、<strong>vconsole</strong>、<strong>mlogger</strong></li><li>版本发布更新，关键词：<strong>发布系统</strong>、<strong>灰度发布</strong></li><li>访问量实时监控</li></ul><h3 id="起步：项目构建的搭建"><a href="#起步：项目构建的搭建" class="headerlink" title="起步：项目构建的搭建"></a>起步：项目构建的搭建</h3><h4 id="使用-webpack-搭建脚手架"><a href="#使用-webpack-搭建脚手架" class="headerlink" title="使用 webpack 搭建脚手架"></a>使用 webpack 搭建脚手架</h4><p>目前在一般的项目中，我们都会使用 webpack 作为搭建开发环境的基础，而 react 和 vue 也各自提供了 cli 工具用于开发一个中小型项目，react 提供了 eject 功能让我们可以更加自由的配置 webpack，而 vue 脚手架虽然没有提供类似命令，但是借助 webpack 工具链我们几乎也可以自由定制每一个角落。</p><p>不过，这里我的建议是，如果是个人项目或小型项目，我们可以基于 react 或 vue 的脚手架进行更改使用，对于一个具备一定规模的项目团队，建议还是自己维护一套单独的 webpack 构建环境，原因如下：</p><ul><li>由于我们一般需要在项目中接入各类司内工具、支持高级API和语法、同时支持 react/vue、构建目录定制化等各类工作，实际上 80% 以上的工作我们都需要在模版之上自行添加，这个时候我们再用脚手架带来的收益已经非常小了，反而还会受制于项目的初始目录结构。</li></ul><p>我们在自定义脚手架的 webpack 构建的时候，也需要梳理出一定的目录规范与约束，这样也有利于提高后期脚手架的可维护性和扩展性，一般来说，我们也要对脚手架中的公共部分和项目私有部分进行分离，对于一个具体项目而言，可以不用改动 webpack 的项目公共部分，这样也有利于减少不同项目之间的切换成本，对于我们目前的项目，一般会有如下两个目录：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> project</span><br><span class="line"><span class="bullet">-</span> project.js</span><br><span class="line"><span class="bullet">-</span> config</span><br><span class="line"><span class="bullet">-</span> feature</span><br><span class="line"><span class="bullet">-</span> plugins</span><br><span class="line"><span class="bullet">-</span> rules</span><br><span class="line"><span class="bullet">-</span> script.js</span><br><span class="line"><span class="bullet">-</span> webpack.base.js </span><br></pre></td></tr></table></figure><p>对于一个项目，只需更改 project 下的配置。</p><p>这里我也推荐一个前同事做的<a href="https://github.com/steamerjs">steamer研发体系</a>，在从中也可以找到很多相关参考，最简单的方式，就是直接在<a href="https://github.com/steamerjs/steamer-simple">steamer-simple</a> 的基础上进行扩展。</p><h4 id="定制生成目录"><a href="#定制生成目录" class="headerlink" title="定制生成目录"></a>定制生成目录</h4><p>生成目录的格式，这里需要单独讲一下。</p><p>一般来说，我们生成目录的格式都是要跟发布系统进行结合的，不过也有的时候，我们做项目的时候还没有明确要接入发布系统，或者尚不知道发布系统的格式要求，但是一般情况下我们应当遵循下面的约定：</p><ul><li>js/css/img 等资源文件和 html 文件分离，前者发布到 CDN，后者发布到 http 服务器。</li><li>html 中引入的文件地址，应当是在构建过程中更新的 CDN 地址，而不是相对路径地址。</li><li>如果有离线包（offline 能力需要对应的客户端 webview 支持）等，需要单独一个目录。</li></ul><p>对于我们目前的项目而言，一般情况下会有三个生成目录：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> cdn</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> offline <span class="comment"># 需要客户端支持该能力</span></span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby"> webserver</span></span><br></pre></td></tr></table></figure><p>如果一开始我们把所有内容生成到一个目录中了，这给我们后期的改动和维护，都带来很大的隐患。</p><h4 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h4><p>组件库这一部分，适合项目开始变得复杂的情况下进行启动，而不建议一开始进行过渡设计，建设组件库能够通过组件复用降低我们的开发成本，同时，组件库也需要专人维护，保持更新。</p><h3 id="开发：代码的规范约束"><a href="#开发：代码的规范约束" class="headerlink" title="开发：代码的规范约束"></a>开发：代码的规范约束</h3><p>对于 js 文件的代码格式，诸如要不要分号、两个还是四个字符缩进等，一只争议不断，本文也不对此进行讨论，但是对于一个团队的项目集合（而不是单个项目）而言，代码风格的统一，是一个非常有必要而且必须要做的事情。</p><h4 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h4><p>关于 typescript 的相关文章实在太多了，这里也不对此进行详细的说明，其对代码的可读性、规范约束、降低报错风险等都有很好的改进，对于越复杂的项目其效果越明显。</p><p>另外， <a href="https://ts.xcatliu.com/">typescript 入门教程</a>的作者也在我们团队中，这里我想说，如果现在还没有开始使用 typescript，请开始学习并使用 typescript 吧。</p><h4 id="eslint-与-prettier"><a href="#eslint-与-prettier" class="headerlink" title="eslint 与 prettier"></a>eslint 与 prettier</h4><p>除了 typescript 以外，在代码格式方面还建议使用 eslint 和 prettier 来进行代码格式的约束，这里虽然 eslint 和 prettier 两者在某些情景下会有些重叠，但是两者的侧重点不同，eslint 侧重于代码质量的检查并且给出提示，在某种层面上，可以看作是 typescript 的补充，而 prettier 在格式化代码方面更具有优势，并且 prettier 在设计之初就考虑了和 eslint 的集成，所以你可以完全放心的在项目中使用两者，而不用担心出现无法解决的冲突。</p><p>另外，eslint 社区中已经形成了很多种最佳实践，而我们团队也设计出了自己的一套 eslint 规则，可以按需<a href="https://github.com/AlloyTeam/eslint-config-alloy">取用</a></p><p>p.s. 目前 tslint 后续计划不在维护，转向 eslint 增强，因此我们在项目中可以不再使用 tslint。</p><p>以上这几种代码风格方面的约束，适合项目之初即开始约束，这样在中后期会有巨大的时间成本的节省和效率的提升。</p><h3 id="协作：使用-git"><a href="#协作：使用-git" class="headerlink" title="协作：使用 git"></a>协作：使用 git</h3><p>使用 git 进行协作这里其实包括两个点，使用 git 管理项目与自建 gitlab，后者是一个比较基础性的工作，并且实际上难度并不大，我认为每一个公司都可以使用自建的 gitlab 进行版本管理，这个实际上难度并不大，并且可以有效的保护公司的代码财产，如果你所在的公司还没有，那么这也是你的机会。</p><p>在具体的使用 git 中，对于git的分支/TAG管理、PR规范、提交文件约束等都应当有一套合理的流程，这里我对几点比较重要的进行说明：</p><ul><li>锁定主干与分支开发，我们在日常开发中禁止直接提交主干，而是只能在分支中进行开发，并且通过 MR 的方式提交到主干。</li><li>git hooks 检查：我们应该通过 git hooks 进行必要的检查，比如自动化测试、eslint 检查、以及一些项目中必要的检查。</li><li>MR 检查与 Code Review，这里建议在 Merge Request 的时候做两件事情，一件是 Code Review，不过这个在某些特殊情况下不具备条件，尤其是团队人力紧张的时候，另外一个则是 MR 的 HOOK 触发检查，这个一般需要借助一些持续集成工具来完成，可以说是我们代码在合并主干之前的最后一个关卡。</li></ul><h3 id="测试：测试与测试部署"><a href="#测试：测试与测试部署" class="headerlink" title="测试：测试与测试部署"></a>测试：测试与测试部署</h3><p>测试是代码开发中重要的一个环节，但实际上对于前端开发来说，前端开发工程师一般较少书写测试用例，也并没有专业的测试开发工程师来辅助工作，不过，一般会有配备系统测试工程师在黑盒的情况下进行冒烟测试和功能测试以及整体链路的验收，俗称“点点点”。而这个时候，前端开发要做的就是把程序代码部署到测试服务器上，同时提供一个尽可能真实的场景供测试进行测试。</p><p>在笔者经历的项目中，虽然也使用了单元测试、端对端测试，不过这一部分体系并不十分完备，并且可能也不是大多数前端开发者感兴趣的内容，所以这里主要总结如何进行高效的测试部署与发布对接。</p><p>一般来说，我们一般会有一台到多台 Linux 测试机，供测试环境部署使用，对于前端项目而言，一般不需要特殊环境，可以进行 webpack 构建以及有 nginx 进行转发即可。</p><p>而测试环境的部署，如果是让我们手动登录去部署，显然是不合理的，如果我们纯粹使用 CI 来完成这件事，则对 CI 工具的能力和项目人员素质有一定要求，并且不具备可视化管理能力，容易出错，这里我建议可以维护一个可视化系统来进行测试环境的部署和管理，其整个环节应该是这样的：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本地代码 -&gt; gitlab -&gt; 测试系统部署 -&gt; 对接发布系统 </span><br></pre></td></tr></table></figure><p>这里的测试系统，实际上是从 gitlab 拉取代码，并且本地执行 build 命令（一般是 <code>npm run build</code>）并把构建结果存储在 nginx 可代理的目录即可，出于系统完备性考虑，一般我们会有多台测试机，这里我建议一般拿其中的一台作为构建机，其他的测试机仅提供 nginx 代理能力即可，我们在一台构建机中进行构建，并且将构建结果通过系统命令发送到其他的测试机。</p><p>一台构建机可以服务于所有的项目，这里还可能涉及到 webpack、nodejs 版本的维护，我们需要约束各个测试项目构建处在一个相对独立的环境中，我们也可以使用过 Docker 来进行构建，保证隔离。</p><p>构建完成后，一般我们借助 Fiddler、Charles、Whistle 等任意一款代理工具，即可以进行测试。</p><h3 id="监控：日志查看与脚本错误的监控"><a href="#监控：日志查看与脚本错误的监控" class="headerlink" title="监控：日志查看与脚本错误的监控"></a>监控：日志查看与脚本错误的监控</h3><p>对于前端项目而言，即使我们已经使用了 typescript、eslint 并且也有了一些测试脚本和系统测试工程师进行的功能测试，我们还是免不了会出现 js 脚本错误，特别是 js 代码的运行环境和设备的多样化，很多错误我们并没有发现，但是产品、运营同学却出现了，或者到了线上在用户设备上出现了。</p><p>所以，有两个事情我们必须要做：</p><ol><li>日志查看功能（手机端）：现在我们写的大多数 TO C 页面都是在手机端进行，查看 console 非常不方便，我们需要一个线上实时查看 console 的工具。</li><li>我们需要脚本错误日志统计系统来进行错误统计管理与具体错误查看。</li></ol><p>对于第一个功能，进行细分，我们需要做这样几件事情：</p><ul><li>嵌入一个 console 和 网络请求查看器，并且只在特殊情况下才能触发（比如连续点击标题十次、或者使用特定交互手势）</li><li>在触发查看器的时候，可以将日志完整地进行上传并分析。</li><li>同时可以对该用户进行染色，会自动上传并记录该用户一定时间内后续刷新后操作的全部日志。</li></ul><p>不过这里并没有完全实现以上三点的开源库推荐，可以在 <a href="https://github.com/Tencent/vConsole">vconsole</a> 或者 <a href="https://github.com/AlloyTeam/MLogger">mlogger</a> 的基础上进行适当扩展，完成相关功能。</p><p>对于第二个功能，我们需要一个完整的统计分析与管理的错误系统，这个如果自行开发的话，难度会比较大，这里强烈推荐 <a href="https://sentry.io/welcome/">sentry</a>，可以非常方便的使用 Docker 部署到服务器端，并且拥有非常强大的日志错误分析与处理能力，通过结合 JavaScript 的 sourcemap ，可以给我们的错误定位带来极大的方便。</p><p>总之，日志查看与脚本错误监控，是比较重要但是同时容易被忽视的地方，很多时候，我们的系统在线上使用了几个月了，真正有问题反馈了，我们才会考虑加上这些功能，但这个时候通常已经造成了损失。</p><h3 id="发布：版本发布更新"><a href="#发布：版本发布更新" class="headerlink" title="发布：版本发布更新"></a>发布：版本发布更新</h3><p>发布系统，一般作为前端最后环节的系统，通常会和测试部署系统打通（或合二为一），一般的发布系统的必要功能如下：</p><ul><li>对于前端的发布，每次只发布有改变的文件，无变动的文件则无需发布。</li><li>每次发布先发布 js/css/img 等资源文件，生效之后再发布 html 文件。</li><li>发布系统保留线上旧版代码，出问题后可以快速一键回滚。</li></ul><p>至于一些其他的日志、报表等辅助性功能，则根据需要满足，这里不再赘述。</p><h4 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h4><p>灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1-5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量较大的页面。</p><p>对于前端的灰度，实际上有以下几种方案：</p><ul><li>在代码层面进行灰度，即通过 if/else 进行判断，这样无需发布系统关注，也可以自由配置规则、比例与白名单/黑名单。</li><li>在入口层面进行灰度，比如 App 内嵌的 H5 则在客户端的对应入口进行回复，这样通常也无需发布系统关注。</li><li>通过发布系统，按照比例灰度，比如我们有 10 台 webserver，如果我们先发布 1 台，这样我们的灰度比例为 10%。</li></ul><h3 id="访问量实时监控"><a href="#访问量实时监控" class="headerlink" title="访问量实时监控"></a>访问量实时监控</h3><p>最后一点，我们还需要一个访问量实时监控系统，我们上述有了错误查看与脚本监控系统，但是对于我们的各个页面的访问量、点击率等指标，通常是产品/运营同学比较关心的，同时访问量的波动情况也是项目健康度的一个表征（访问量突然大幅上涨或下跌，一般都有其特定原因），所以我们需要访问量实时监控系统。</p><p>而实际上访问量监控系统也有两种不同形态：</p><ul><li>对于每一个上报 key，只进行数量上的统计</li><li>对于每一个上报 key，可以携带一些信息，对携带信息进行统计分析。</li></ul><p>通常情况下，前者的功能是实时或者低延时的，而后者由于需要一部分统计分析，通常可以接受非实时情况（一般每天出前一天的报表）。</p><p>这部分内容，需要较强的后端接口稳定性，通常前端需要和对应岗位的同学共建。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总结下来，我们一个稳定的前端项目，至少涉及到以下环节：</p><ul><li>完善的项目脚手架与代码约束规范</li><li>内部 gitlab</li><li>可视化管理的测试部署系统</li><li>实时日志查看工具</li><li>脚本错误统计管理系统</li><li>发布管理系统</li><li>访问量实时监控系统</li></ul><p>如果你所在的团队哪个环节还没有或者不完善，那么这也是你的机会。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文基于笔者在腾讯的项目经验，从真实场景出发分析一个中型 Web 应用从立项到上线稳定运行的平稳解决方案，力求既不太空泛以至于看完了仍然找不到落地的点，也尽量不会特别纠结于个别细节导致没有相关使用经历的同学无法感同身受，而是从宏观到方法论，分析整个流程中我们需要用到的工具、</summary>
      
    
    
    
    
    <category term="前端构建" scheme="http://niexiaotao.cn/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>qlc解决了什么问题</title>
    <link href="http://niexiaotao.cn/2019/02/16/qlc%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/"/>
    <id>http://niexiaotao.cn/2019/02/16/qlc%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98/</id>
    <published>2019-02-16T11:17:31.000Z</published>
    <updated>2022-04-13T07:07:01.189Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目前遇到的问题"><a href="#目前遇到的问题" class="headerlink" title="目前遇到的问题"></a>目前遇到的问题</h3><p>作为一名前端工程师，陆陆续续负责了不少项目，这些项目中，有一些是正在迭代的，其他同事同时在负责的项目，但是也有不少项目，要么就是老旧项目维护的同事已经离职或转岗了的，要么就是新项目从 0 开始的，再加上前端代码积累速度和迭代速度都比较快，其中暴露了不少问题。</p><p>我身边的大多数程序员都有一个特点，就是喜欢把具体的东西抽象化，我们通常会抽象出公共的函数或方法、公共的类或HOC，放在一起，集中在项目的某一个文件夹下，叫做 js 文件夹或 lib 文件夹（以下我们用 js 文件夹代表公共函数文件夹 ）。</p><p>这样做的确带来了很多便利，但同时也有一些隐患：</p><ul><li>js 文件夹下代码越来越多，而且大多数鹅厂小伙伴的作风是 0 文档 0 注释，这给新接手项目的同学熟悉项目带来了极大的麻烦。</li><li>不同项目都有自己的 js 文件夹，在开发一个新项目时，我们通常的做法是：<ul><li>直接将原有项目的 js 文件夹拷贝到新项目中，这样在新项目中，我们也可以直接使用这些公共函数了。</li><li>将原有项目的部分 js 文件拷贝到新项目中，并且随着新项目的开发，增量拷贝。</li><li>以上两种做法，本质区别不大，前者会直接给新项目增加很多无用代码（原有项目中所谓的公共函数在新项目中并不一定会用到），而对这两种方式，如果我们要修复一个 bug，修改或升级公共代码中的一个文件，那么我们就要一个一个的，将修复好的文件拷贝到不同的项目中，如果项目多了并且已经交由不同的人维护了，这简直是一个灾难。</li></ul></li><li>由于公共 js 文件夹下内容比较多，并且有的开发同学习惯以 ‘urlUtils.js’、’strUtils.js’ 这种方式来整合一些小的函数集，这样会造成函数重复的隐患（毕竟我们一个文件一行行的去分析目前的公共库已经有了哪些能力是不现实的），我观察过之前自己接手的一个不算复杂的项目（潘多拉），其仅仅是从 url 解析 query 这种功能函数，就有多达 3个(甚至更多)，分布在 js 文件夹以及 node_modules 里面，这显然是不同的维护人员由于信息不对称重复引入的。</li><li>对于怎么样才能算作“公共”函数，目前是缺乏一个 review 过程的，任何项目开发人员，几乎都可以无限制地在公共 js 文件夹下增加内容，并在之后被携带着拷贝到其他项目中，这其中有些函数，也许并不适合在这里。</li></ul><h3 id="问题归纳与解决"><a href="#问题归纳与解决" class="headerlink" title="问题归纳与解决"></a>问题归纳与解决</h3><p>实际上，总结下来，我们需要解决三个痛点：</p><ul><li>以低成本的方式增加高可读性的文档，方便新接手项目的同学熟悉。</li><li>解决跨项目之间的公共函数复用和更新维护困难的问题。</li><li>增加必要的 review 环节，对公共函数库的必要性和代码正确性进行 review。</li></ul><p>就第一个问题而言，其实现在的前端文档工具链已经极大降低了写文档的成本了，利用 <a href="http://usejsdoc.org/">jsdoc</a> 或 <a href="https://esdoc.org/">esdoc</a> 等文档生成工具，我们基本上已经不需要手动写文档，而是在写代码的同时写注释，就可以自动生成文档，并且配合相关的编辑器插件，一部分注释都可以自动生成。</p><p>但是目前我经历的大多数项目还是没有文档，这里可能是由于以下四个原因：</p><ul><li>部分同学并不知道有 esdoc、jsdoc 这种比较好用的文档生成工具。</li><li>开发组中没有人去推动，文档不属于 KPI 和考核的内容，加之时间紧迭代快，缺乏前人栽树的动力。</li><li>虽然现在的文档生成工具比较简单了，但一般还是需要一定的配置，也有一点上手成本。</li><li>生成的文档不能十分满足需求，例如 esdoc 默认只能生成 html 格式的文档，在编辑器里面没法直接看。</li></ul><p>针对第一个问题，qlc 做出了一些努力：</p><ul><li>0 配置，全自动化生成文档，甚至集成到了其他开发流程中，命令行也不用敲。</li><li>基于 esdoc 以及开源插件二次开发，可以选择性生成 html 和 markdown 格式的文档，注重文档体验。</li><li>基于 esdoc 注释写作成本更低，更能节省时间。</li></ul><blockquote><p>跟 jsdoc 相比，esdoc 使用方式比较简单，不需要严格使用标签，而且能够支持搜索，并且官方资料更为齐全。</p></blockquote><p>至此，使用 qlc 生成文档，已经非常简单了。</p><p>第二、第三个问题实际上是公共函数库的维护问题，qlc 也设计了对应的流程，着力解决该问题：</p><ul><li>首先有一个远程公共库（基于 git）。</li><li>对于某一个项目而言，可以从远程库中下拉所需要的公共函数/类，并自动生成文档。</li><li>如果我们对某一个项目增加了一个公共函数并且认为可以为更多的项目所用，命令行上传到远程库自动触发 MR，维护人员 review 通过后即可供其他项目使用。</li><li>修复或更新某一个公共函数之后，我们只需同步到远程库，其他项目维护人员在命令行工具的辅助下同步即可。</li></ul><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>到此，你是否认为 qlc 给你带来了一定的价值呢，可以到 qlc 的官方仓库查看更多的<a href="https://git.code.oa.com/qlc/qlc">文档细节</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;目前遇到的问题&quot;&gt;&lt;a href=&quot;#目前遇到的问题&quot; class=&quot;headerlink&quot; title=&quot;目前遇到的问题&quot;&gt;&lt;/a&gt;目前遇到的问题&lt;/h3&gt;&lt;p&gt;作为一名前端工程师，陆陆续续负责了不少项目，这些项目中，有一些是正在迭代的，其他同事同时在负责的项目</summary>
      
    
    
    
    
    <category term="javascript" scheme="http://niexiaotao.cn/tags/javascript/"/>
    
  </entry>
  
</feed>
