[{"title":"外汇投机指南","url":"/2022/04/17/Speculation_on_forex/","content":"**外汇投机指南**\n> Editing\n\n#### 为什么选外汇\n1. 它超级大盘，EURUSD这种货币对几乎无人能操纵\n2. 外汇的信息获取非常充足\n3. 极小的入市成本，0.01手，一美金都能做交易\n\n#### 平台和工具\n- Python 3.8.8\n- MetaTrade5\n- MetaTrade的Python Module\n- 一个外汇佣商的账号\n\n#### 背景知识\n这里以EURUSD为介绍\n这个货币对叫做欧元/美元，在交易系统上有两个价格 卖价（bid）买价（ask）\n这个都是对于交易者来说的，也就是ask就是市场上你能买到的最低价,bid就是市场上你能卖的最高价\nask >= bid，点差就是ask-bid，点差是可以为0的，例如EURUSD行情比较平缓时，点差为0\n\n#### 怎么赚钱\n外汇的波动非常小，需要用杠杆放大，交易所会借钱给你，帮你放大波动用于赚钱\n例如 你有10美元，用2000倍杠杆，此时你如果在1.01254这个价位做空0.01手，交易所会借给你1000美元，你需要用1000/2000 = 0.5美元作为保证金\n此时如果价格从1.01254波动到1.01200,那么你就用了0.5美金赚到了(1.01254 - 1.01200)*1000 = 0.54美金\n(这里没有计算点差费用和手续费，用于做一个简单说明)\n\n#### 这个赚钱吗风险怎样\n依旧以EURUSD为例，它的每小时波动标准差为0.000705641339641201,也就是如果你用2000的杠杆，用0.5美元做保证金，如果赌对了，平均能赚到0.7美元\n以三个月内的小时线做了分布图\n\n<img src=\"/img/forex/forex_pic.png\" />\n大概率都落在0.002的波动范围内，也就是用2000倍杠杆，0.5美金能赚2美金\n风险有多大呢，如果汇率往另外一个方向波动0.0005不到，你的0.5美金全部消失\n\n#### 常见交易方法\n1. MACD/RSI/Bollinger Bands/EMA\n这一部分我用Python和EA都跑过，模拟盘没有赚到钱\n\n2. 滚仓\n先开一个单，如果盈利了就继续加仓，这个有赚到过一点点\n\n3. 马丁策略\n这个是非常著名的策略，胜率非常高，但是一旦失败，就爆仓，网上有非常多的教程也有现成的\n我贴一下我的模拟盘净值,分别是失败和成功的\n\n<img src=\"/img/forex/martin_failed.png\" />\n<img src=\"/img/forex/martin_success.png\" />\n\n#### 参考代码\nhttps://github.com/presentzeng/forex\n\n","tags":["Fun"]},{"title":"6S081 Study Notes","url":"/2022/02/01/6S081/","content":"#  Introduction && Link:\nIt is a Note about The MIT course 6.S081. arranged by following it's lab order\nhttps://pdos.csail.mit.edu/6.S081/2021/index.html\nhttps://pdos.csail.mit.edu/6.S081/2021/labs/util.html\n\n# Lab1 Utilities\n## Key Points\n1. The kernel uses the hardware protection mechanisms to ensure that each process executing user space can access only its own memory\n2. Fork creates a new process, called the child process, with exactly the same memory contents as the calling process\n\n\n### pingpong\n- what is the difference of two code block\n```\nint fd[2];\npid=fork();\npipe(fd);\n```\n```\npid=fork();\nint fd[2];\npipe(fd);\n```\n all have 4 fd genereated\nbut the first one two process's fd have no connection.\nand the second one has\n\n- remember to exit at every child process, otherwise it will execute the code below\n\n### xargs\n- what is char* a[10]?\n> format a =  {char* char* .... char*}\n- exec(command, argv)\n > the argv[0] should be not be filled with parameter but with command name\n- there are two types format: \"123\\n456\" and 123 456, how we deal with it.\n> we can devide with space of \\n and treate \" as one of the char, delete it at the last step\n- we should clear all the uninitial string otherwise we will get random value like \"\\\" which will cause a lot of confusion to us\n![random value](/img/1650726024.png)\n- if you wanna pass char par[10][10] as a parameter in function you should write prototype like below\n> func(char * par[10][10]), that means you should write out the dimension of it\n- what is the difference \n> char *par[] = {}; char * par[10] = {}; char *par[10],  the former two are empty array, the last one is the right defination\n- why we should fork and call exec \n> exec system call will replace the the calling process, that is why\n- what is the difference between strlen and sizeof\npls Do use sizeof with memset\n- we can compare char with == but we should compare string by using strcmp\n- \"\" is a string '' is a char\n- how to use pointer array properly\n```\n    char *pass_par[10]; \n    char * test = \"xargs\";\n    pass_par[0] = test;\n    printf(\"%s\\n\", pass_par[0]);\n \n```\n\n# Lab2 System calls\n## Mode\n> mode\n\nMachine\nmode is mostly intended for configuring a computer\n\nsupervisor mode is for executing privileged instructions: for example, enabling and disabling interrupts, reading and writing the register that holds the address of a page\ntable\n\nCPUs provide a special instruction that switches the CPU from user mode\nto supervisor mode. (RISC-V provides\nthe ecall)\n\nxv6 is monolithic kernel, with all kernel in one mode\n\n> Kernel\n\nthe hardware only uses the low 39 bits when looking up virtual addresses in page tables; and\nxv6 only uses 38 of those 39 bits. Thus, the maximum address is 2\n38 − 1 = 0x3fffffffff\n\nEach process has two stacks: a user stack and a kernel stack\n\nIn Entry.S it's _entry set up a stack so that xv6 can run C code start.c\n\n### System call tracing\nPreparation:\n1. read at least twice the instructions\n2. add print command to check the execute order of each function\n3. you can check how the kill pass all the argument\n\nNote:\n1. The most important part is how to pass the argument to the system call\n2. To read the document, you will know the argument is stored in which Register, and you can use function argint\nto \"Fetch the nth 32-bit system call argument\"\n\n### Sysinfo \nPreparation:\n1. the trick part about the compilation is pls use sys_sysinfo instead of sys_info\n2. A process’s most important pieces of kernel state are its page table, its kernel\nstack, and its run state.\n3. sysinfotest -> kernel/sysproc.c -> kernel/kalloc*proc\n\nNote:\n1. The most important part is to understand the function copyout\n2. for counting proc, we should caculate all the proc that not in UNUSED mode\n3. for counting mem, we should times the page size\n\n# Lab3  Page Table\nNote:\n1. VA and PA is translated by map\n2. MMU won't store any map\n3. kernel will write the map value into the satp register\n4. page is 4 KB in the Risk V\n5. for satp, it is divided into three pieces 25+27+12, 12 is the byte within the page, index is for the map to translate to physical page\n6. every process keeps it's own page table\n7. Kernel is using \"direct mapping\"\n\n\nThe Steps to translate the virtual to physical\n1. the virtual address is devided into PTE-selector and offset, for example 9+9+9(PTE-selector) + 12(Offset)\n2. for the first page table it is satp + value(first 9 bit), in it we can get the PPN of next page(it's physical address)\n\n### rewrite Walk in non recursive way\n1. pte = page table entries\n2. ppn = physical table number\n3. pagetable is an array string like below\n[pte1, pte2, pte3 .... pte512]\n4.  Each PTE contains a 44-bit physical page\nnumber (PPN) and some flags\n5. Sv39 Risc-V only uses bottom 27 bit for virtual address, that means 27 power of 2 is the max number of PTES\n6. each pte actually uses 64 bit(8 byte), but it only uses the bottom 54 bits\n7. each page table has 512 ptes, in total it is 4096 byte\n8. pte = ppn(44) + flag(12)\n9. physical address is 56 bit\n10 last physical address(56) = ppn(44) + Virtual offset(12)\n11. the middle physical(56)= ppn(44)+ empty zero(12)\n\n### Free process's memory\n1. it should free it's page table and the physical memory it refers to\n2. Is only the leaf pagetable has the PTE_R PTE_W flag?\n\n","tags":["Linux","System","OS"]},{"title":"Common Weakness","url":"/2020/02/21/Common_Weakness/","content":"# Common Weakness\n> Editing\n\n### Input validation\nIf we don't validate input properly, Hacker can alter control flow,  change the code execution, or get the Important file informations\n\ne.g:\n[CWE-790][1]\n[CWE-116][2]\n[CWE-138][3]\n\n[1]: https://cwe.mitre.org/data/definitions/790.html\n[2]: https://cwe.mitre.org/data/definitions/116.html\n[3]: https://cwe.mitre.org/data/definitions/138.html\n\n### Defense\n1. Consider all the aspect:Value Type /  Length / Format / Expired Time / Effect Scope and so on\n2. Assume all input is malicious, Only accept the thing that we know, That means we only set the whiltlist\n","tags":["Security"]},{"title":"Born","url":"/2000/01/01/Born/","content":"**Simple Introduction**\n\n#### Initial\n\"Right at this moment, I was born\" -- Millennium Bug","tags":["Fun"]}]